"Ｎクイーン問題（３８）第七章　ブルートフォース Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)



## Ｎクイーン問題 Python版について
Ｎクイーン問題とは、ＮxＮの盤面にチェスのクイーンＮ個を、互いに効きが無い（クイーンは縦・横・斜め45度方向に効きがある）状態で配置する問題です。

配置したすべてのクイーン同士が効きに当たらない配置の１つはい以下のようなものです。
```
        column(列)
   _4___3___2___1___0_
  |---|---|-Q-|---|---|0
  +-------------------+
  |---|---|---|---|-Q-|1
  +-------------------+ 
  |---|-Q-|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|-Q-|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```

一般的には８×８のチェス盤を用いる８クイーン問題が有名です。
多くのエイトクイーン研究者は盤面の縦横行列を８に固定せず、 ＮxＮの盤面とし、現実的な処理時間で、Ｎが、どこまでのサイズ（Ｎ）まで解を求めることができるかを競っています。

現在、Ｎ２７の解を求めたドレスデン大学が世界一を記録しています。
詳しくは（１）を参照してください。

N-Queens問題：Ｎクイーン問題（１）第一章　エイトクイーンについて
https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/


## ブルートフォースについて
ブルートフォース（力まかせ探索）は、全ての可能性のある解の候補を体系的に数えあげます。

解の候補が一つ生成される都度、その解の候補が解となるかをチェックします。

解の候補を生成後に「解であるか（それぞれのクイーンの効きに干渉していないか）」をチェックするので「生成検査法（generate and test）」とも呼ばれます。

ブルートフォースの手数は、各列 `row` には１個のクイーンしか置けないので、Ｎ５の場合は、５＊５＊５＊５＊５＝３１２５となり、５＾５，またはＮ＾Ｎと表記します。

したがって、アルゴリズム的に言えば、「力まかせ探索による Ｎクイーン問題の処理時間は Ｏ（Ｎ＾Ｎ）」となります。

よってＮが５の場合のＯ（ビッグオー）は、（Ｎ＾Ｎ）なので、５＊５＊５＊５＊５＝３，１２５ということになります。

簡単に言うと、すごく遅いアルゴリズムということになります。


## 効き筋のチェック
ここでは具体的な説明を割愛しますが、解の候補が生成される都度、以下の効き筋チェック関数が呼び出され、解となりうるかを判定すします。
いわゆるＮ５の場合は、以下のチェック関数が３１２５回実行されることになります。

```python
#
# ブルートフォース版効き筋チェック
def check_bluteForce(size):
  global board
  for r in range(1,size,1):
    for i in range(r):
      if board[i]>=board[r]:
        val=board[i]-board[r]
      else:
        val=board[r]-board[i]
      if board[i]==board[r] or val==(r-i):
        return 0
  return 1
```

各列`col`、行`row`と比べて、横、斜め左右４５度方向に置かれていないかをチェックし、効きがあればその時点で 「０」（false)を返します。（縦は最初から一つしか置けない仕組みになっているのでチェックはしません）

効きがまったく無い場合は 「１」（true） を返します。つまり解を発見したということになります。




## ブルートフォース
ブルートフォースのメインメソッドは以下のとおりです。

```python
#
# ブルートフォース
def bluteForce(row,size):
  col=0
  global TOTAL
  global board
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      bluteForce(row+1,size)
```

for文で各行の何`row`目にクイーンを配置するかを決め、最後まで配置した場合は、`check_bluteForce()` を呼んで、クイーンの配置が「効き」であるかどうかを判定します。

効きでなければ「解を発見した」として `((TOTAL++))`で、解個数をインクリメントします。

ですので、`check_bluteForce()` 関数は、クイーンの効きを判定する関数となります。
重要なことは、クイーンの配置が終わったら

```python
  if row==size:
```
の条件式に入り、その直後で`check_bluteForce(size)`を呼び出して
```python
    if check_bluteForce(size)==1:
```
クイーンの配置に問題がないかをチェックします。
`check_bluteForce()`関数の末尾では以下のようになっています。
チェックをすべて通り抜けることができれば、効いていない（配置したクイーンは他のクイーンと干渉していない）ということになります。

```python
  return 1
```

また、受け取り側の `def bluteForce()` の以下の部分ですが、
```python
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
    check_bluteForce "$size";
```

`check_bluteForce()`関数で、効きの判定を行い、「戻り値が `1` 」で、効きではない（他のクイーンとの干渉はない）と判定されたので、新しく解を発見したことになり、`((TOTAL++))`で合計をインクリメントします。
併せて、`printRecord()`のボードレイアウト表示関数によって、クイーンの位置を表示する、というロジックとなります。


```python
      printRecord(size) # ボードレイアウトを出力
```

は、ボードレイアウトのクイーンの位置を配置する出力関数です。


## ボードレイアウトの出力
ボードレイアウトの出力関数は以下のとおりです。

```python
# 
# ボードレイアウト出力
def printRecord(size):
  global TOTAL
  global baord
  print(TOTAL)
  sEcho=""
  for i in range(size):
    sEcho+=" " + str(board[i])
  print(sEcho)
  print ("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  for i in range(size):
    print("|",end="")
    for j in range(size):
      if i==board[j]:
        print("O",end="")
      else:
        print(" ",end="")
      if j<(size-1):
        print("|",end="")
    print("|")
    if i in range(size-1):
      print("+",end="")
      for j in range(size):
        print("-",end="")
        if j<(size-1):
          print("+",end="")
      print("+")
  print("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  print("")
```



## ブルートフォースのポイント
ブルートフォースのポイントは、
クイーンの配置が終わったら
```python
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
```
その直後でクイーンの効きを判定する `check_bluteForce()` 関数が呼び出されることです。

```python
    if check_bluteForce(size)==1:
```

３１２５回、クイーンの配置が完了する都度、`check_bluteForce()`が３１２５回呼び出されるわけです。

ブルートフォースの遅さの原因はここにあります。


## プログラムソース
再帰版・非再帰版を含むすべてのプログラムソースは以下のとおりです。
プログラムソース最下部で、再帰と非再帰の実行をコメントアウトで切り替えて実行してください。

```python:01Python_bluteForce.py
#!/usr/bin/env python3

# -*- coding: utf-8 -*-
"""
ブルートフォース版 Ｎクイーン

詳細はこちら。
【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから
https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題

エイト・クイーンのプログラムアーカイブ
Bash、Lua、C、Java、Python、CUDAまで！
https://github.com/suzukiiichiro/N-Queens


# 実行 
$ python <filename.py>

# 実行結果
1
 0 2 4 1 3
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
"""

#
# グローバル変数
MAX=21  # ボードサイズ最大値
TOTAL=0 # 解
board=[0 for i in range(MAX)] # ボード配列格納用
# 
# ボードレイアウト出力
def printRecord(size):
  global TOTAL
  global baord

  print(TOTAL)
  sEcho=""
  for i in range(size):
    sEcho+=" " + str(board[i])
  print(sEcho)
  print ("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  for i in range(size):
    print("|",end="")
    for j in range(size):
      if i==board[j]:
        print("O",end="")
      else:
        print(" ",end="")
      if j<(size-1):
        print("|",end="")
    print("|")
    if i in range(size-1):
      print("+",end="")
      for j in range(size):
        print("-",end="")
        if j<(size-1):
          print("+",end="")
      print("+")
  print("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  print("")
#
# ブルートフォース版効き筋チェック
def check_bluteForce(size):
  global board
  for r in range(1,size,1):
    for i in range(r):
      if board[i]>=board[r]:
        val=board[i]-board[r]
      else:
        val=board[r]-board[i]
      if board[i]==board[r] or val==(r-i):
        return 0
  return 1
#
# ブルートフォース
def bluteForce(row,size):
  col=0
  global TOTAL
  global board
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      bluteForce(row+1,size)
#
# 実行
bluteForce(0,5) # ブルートフォース
#
```



## 実行結果
実行結果は以下の通りです。

```
1
 0 2 4 1 3 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
```

どうですか？
遅いでしょう？

ブルートフォースは遅いのです。
効きの判定関数を本体の関数から外に出して別関数としたことで、ロジックがよりわかりやすくなりました。
次のページでは、同様に効きの判定関数を別関数にして、バックトラックの再起と非再帰をご説明します。
お楽しみに！





"Ｎクイーン問題（３９）第七章　バックトラック準備編 Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)


## 前回までのあらすじ
前回の記事では、エイトクイーンの３つのルール
１．縦に一つだけのクイーン
２．横に一つだけのクイーン
３．斜めに一つだけのクイーン

の「１．縦に一つだけのクイーン」を実現する方法を紹介しました。

Ｎ５の時の実行結果ですが、
```
:
:
:
3117:4 4 4 3 1 
3118:4 4 4 3 2 
3119:4 4 4 3 3 
3120:4 4 4 3 4 
3121:4 4 4 4 0 
3122:4 4 4 4 1 
3123:4 4 4 4 2 
3124:4 4 4 4 3 
3125:4 4 4 4 4 
```

Ｎ５の場合、３１２５ステップかかりました。
このステップは計算で算出することが可能です。

５＊５＊５＊５＊５＝３１２５
Ｎ^Ｎ＝３１２５

ということになります。
こうした、可能性のあるすべての解を体系的に「ちからまかせ」に数え上げる方法を、ブルートフォースといいます。



## 今回は、抑制ルールを１つ加えます。
今回は、前回のルールに加え、「２．横に一つだけのクイーン」を追加します。
要するに、縦にも横にもクイーンの効きが当たらないように配置するということになります。

そういう意味で、前回は「ブルートフォース」、今回は少し手を入れている分、「バックトラック準備編」という位置づけでご説明します。
次回は、エイトクイーンの解決方法の金字塔「バックトラック」の完成です。



## 考え方
これまでのクイーンの並びは、以下のような並びであってもカウントしていました。
（できたということにしていました）



```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

今回からは、縦列に一つのクイーンというルールに加えてさらに、「横行にも一つのクイーンしかおけないからね」というルールが追加されるわけです。

まず、スタート段階はクイーンは0列目に一つ(0,0)クイーンを配置します。
```
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

次に１列目にクイーンを配置します。
(1,0)は(0,0)のクイーンの効きとなります。
よって１列目のクイーンは(1,1)に配置されます。
以下のようになります。
```
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

次は2列目ですが、(2,0)も置けません。
同様に(2,1)も置けません。
結果、(2,2)に配置することになります。
```
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

こうして続けていくと、以下のような形で５列全てにクイーンが配置されることになります。

```
4,3,2,1,0

        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|---|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```
縦（各列）に一つだけのクイーン、というルールに加えて、横（各行）に一つだけのクイーン、というルールが加わり、今回の配置によって「一つの解を見つけた」ということになりました。

列と行に一つだけのクイーンという縛りについての検討は、この画面から考えてみるのが良いのです。


問題は、ここからなのです。


## 縦と横の効きを考慮した場合の出力は？

```
1: 4 3 2 1 0 
2: 3 4 2 1 0 
3: 4 2 3 1 0 
4: 2 4 3 1 0 
5: 3 2 4 1 0 
6: 2 3 4 1 0 
7: 4 3 1 2 0 
8: 3 4 1 2 0 
9: 4 1 3 2 0 
10: 1 4 3 2 0 
11: 3 1 4 2 0 
12: 1 3 4 2 0 
13: 4 2 1 3 0 
14: 2 4 1 3 0 
15: 4 1 2 3 0 
16: 1 4 2 3 0 
17: 2 1 4 3 0 
18: 1 2 4 3 0 
19: 3 2 1 4 0 
20: 2 3 1 4 0 
21: 3 1 2 4 0 
22: 1 3 2 4 0 
23: 2 1 3 4 0 
24: 1 2 3 4 0 
25: 4 3 2 0 1 
26: 3 4 2 0 1 
27: 4 2 3 0 1 
28: 2 4 3 0 1 
29: 3 2 4 0 1 
30: 2 3 4 0 1 
31: 4 3 0 2 1 
32: 3 4 0 2 1 
33: 4 0 3 2 1 
34: 0 4 3 2 1 
35: 3 0 4 2 1 
36: 0 3 4 2 1 
37: 4 2 0 3 1 
38: 2 4 0 3 1 
39: 4 0 2 3 1 
40: 0 4 2 3 1 
41: 2 0 4 3 1 
42: 0 2 4 3 1 
43: 3 2 0 4 1 
44: 2 3 0 4 1 
45: 3 0 2 4 1 
46: 0 3 2 4 1 
47: 2 0 3 4 1 
48: 0 2 3 4 1 
49: 4 3 1 0 2 
50: 3 4 1 0 2 
51: 4 1 3 0 2 
52: 1 4 3 0 2 
53: 3 1 4 0 2 
54: 1 3 4 0 2 
55: 4 3 0 1 2 
56: 3 4 0 1 2 
57: 4 0 3 1 2 
58: 0 4 3 1 2 
59: 3 0 4 1 2 
60: 0 3 4 1 2 
61: 4 1 0 3 2 
62: 1 4 0 3 2 
63: 4 0 1 3 2 
64: 0 4 1 3 2 
65: 1 0 4 3 2 
66: 0 1 4 3 2 
67: 3 1 0 4 2 
68: 1 3 0 4 2 
69: 3 0 1 4 2 
70: 0 3 1 4 2 
71: 1 0 3 4 2 
72: 0 1 3 4 2 
73: 4 2 1 0 3 
74: 2 4 1 0 3 
75: 4 1 2 0 3 
76: 1 4 2 0 3 
77: 2 1 4 0 3 
78: 1 2 4 0 3 
79: 4 2 0 1 3 
80: 2 4 0 1 3 
81: 4 0 2 1 3 
82: 0 4 2 1 3 
83: 2 0 4 1 3 
84: 0 2 4 1 3 
85: 4 1 0 2 3 
86: 1 4 0 2 3 
87: 4 0 1 2 3 
88: 0 4 1 2 3 
89: 1 0 4 2 3 
90: 0 1 4 2 3 
91: 2 1 0 4 3 
92: 1 2 0 4 3 
93: 2 0 1 4 3 
94: 0 2 1 4 3 
95: 1 0 2 4 3 
96: 0 1 2 4 3 
97: 3 2 1 0 4 
98: 2 3 1 0 4 
99: 3 1 2 0 4 
100: 1 3 2 0 4 
101: 2 1 3 0 4 
102: 1 2 3 0 4 
103: 3 2 0 1 4 
104: 2 3 0 1 4 
105: 3 0 2 1 4 
106: 0 3 2 1 4 
107: 2 0 3 1 4 
108: 0 2 3 1 4 
109: 3 1 0 2 4 
110: 1 3 0 2 4 
111: 3 0 1 2 4 
112: 0 3 1 2 4 
113: 1 0 3 2 4 
114: 0 1 3 2 4 
115: 2 1 0 3 4 
116: 1 2 0 3 4 
117: 2 0 1 3 4 
118: 0 2 1 3 4 
119: 1 0 2 3 4 
120: 0 1 2 3 4 
```

１２０とおりです。
これはＮクイーンの解ではありません。
ブルートフォースで言うところの「手数」が３，１２５通り。
ということが、縦と横の効きを考慮した場合は、
５＊４＊３＊２＊１＝１２０通り。
ということになります。

バックトラック準備編と言っているのは、
・バックトラック（次編）は縦と横と斜めの効きを考慮
・今回のバックトラック（準備編）は、縦と横だけの効きを考慮したもの

です。縦と横の効きを考慮した場合のクイーンの動きをきちんと理解しておくほうが後々に効いてくるのです（Ｎクイーンだけにｗ）


## 順を追って見ていきます。
実行結果を順を追ってみていきましょう。

この作業はとても重要です。
この作業をやることなく次に進んでもまったくといってよいほど意味がありません。
理解していなくてもステップを進むことはできますが、理解していないから身につかないのです。
バカバカしいと思わずに、実行結果を順番にボード上のクイーンを配置しつつ、動きを確認してください。

では、実行結果の解を上から順を追ってみていきます。

１つ目の実行結果は

```
1: 4 3 2 1 0 
```

でした。
この盤面情報を図に置き換えるとどうなりますか？


```
1: 4 3 2 1 0 

        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|---|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```

さてここで、どのクイーンが動くのかというところが重要です。
動くのは盤面の左側である「先っぽ」となります。
とはいえ、(4,4)のクイーンはもう最下部まで到達しています。
再帰では最下部へ到達しているその条件を「基底条件」というのでしたね。

<font color=red>「４列のクイーンはこれ以上手がない状態」といえます。</font>


ここで操作している４列に「↓」マークを付けておきます。
いずれこの矢印が役に立ちます。

```
   ↓
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|---|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```

さて４列にこれ以上「手がない」ということになり初めて、一つ手前３列のクイーンに軸が移動します。

ここでは「↓」が右に一つずれます。
```
       ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-x-|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|---|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```
軸（↓）にある(3,3)のクイーン可能性のある移動箇所を探します。
(3,0),(3,1),(3,2)はアタリでおけません。
(3,3)は現在の場所となりますし、
(3,4)に移動できそうですね。
盤面は以下のとおりです。
```
       ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-x-|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|-x-|---|---|---|3
  +-------------------+
  |-Q-|-Q-|---|---|---|4
  +-------------------+
```

`col3`列のクイーンは(3,4)へ移動しました。
となると、ここから`col4`列のクイーンの移動が始まります。
(4,0),(4,1),(4,2)まではアタリですね。(4,3)....
(4.3)におけますね。

これで、２つ目の解ができあがります。
盤面は以下のとおりです。

```
2: 3 4 2 1 0 
       ↓
        column(列)
   _4___3___2___1___0_
  |-x-|---|---|---|-Q-|0
  +-------------------+
  |-x-|---|---|-Q-|---|1
  +-------------------+ 
  |-x-|---|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |-Q-|-x-|---|---|---|3
  +-------------------+
  |---|-Q-|---|---|---|4
  +-------------------+
```

(4,4)は(3,4)のクイーンのアタリなので移動できません。

これで<font color=red>「`col4`列のクイーンはすべての可能性を探し終わった」</font>といえます。

ですので３列のクイーンを桁上りしたいところなのですが、残念ながら`col3`のクイーンはすでに最下部へ到達しており、
<font color=red>「３列のクイーンはこれ以上手がない状態」</font>と、なりました。

ここで軸「↓」を `col3`から`col2`へずらします。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-Q-|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

先程と同様、手がない状態となると「一つ手前の」列である２列のクイーンが「ひとつずれてみようか」と下(2,3)に移動し桁上りします。

元の場所にはわかりやすく「x」マークを付けておきました。
盤面は以下のようになります。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|---|-Q-|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

ここからいつもの処理が始まります。

`col3` 列のクイーンは移動できる可能性を最上部から順にたどります。

(3,0),(3,1)はアタリとなり置けません、(3,2)に置けそうですね。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-Q-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|---|-Q-|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

ここで４列目の移動候補を最上部から順番にたどります。
(4,0),(4,1),(4,2),(4,3),(4,4)
(4,4)におけますね！

これで３つ目の解が見つかったことになります。
盤面は以下の通りとなります。


```
3: 4 2 3 1 0 
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-x-|-Q-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |-x-|---|-Q-|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```

さて、現在の矢印↓の場所は `col2` です。
また、(3,2)のクイーンの位置で展開した `col4`列で移動できる可能性は上から順にすべて潰しました。

そこで、３列はひとつ下(3,3)にずれます。
アタリですね。

さらにひとつ下の(3,4)にずれます。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|-x-|-Q-|---|---|3
  +-------------------+
  |---|-Q-|---|---|---|4
  +-------------------+
```

さて `col4`列目の移動候補を気を取り直して上から順番にたどりましょう。
(4,0),(4,1),(4,2)

まず(4,2)へ移動できそうですね。
盤面は以下のとおりです。
ここで４つ目の解ができました。
盤面は以下のとおりです。

```
4: 2 4 3 1 0 
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-Q-|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|-x-|-Q-|---|---|3
  +-------------------+
  |---|-Q-|---|---|---|4
  +-------------------+
```

４列目の続きも見てみましょう。
(4,3),(4,4)はアタリですので置けませんね。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-Q-|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |-x-|-x-|-Q-|---|---|3
  +-------------------+
  |-x-|-Q-|---|---|---|4
  +-------------------+
```
`col4`列目の可能性はすべて潰しました。
さらに３列目(3,4)のクイーンは最下部となりました。
`col4` `col3` でもう動かせる可能性はありません。

<font color=red>「`col2`列(2,3)のクイーンはこれ以上手がない」状態</font>なので、

`col2`列(2,3)のクイーンは(2,4)へ移動します。
盤面は以下のとおりです。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|---|-x-|---|---|3
  +-------------------+
  |---|---|-Q-|---|---|4
  +-------------------+
```

ではいつものとおり `col3`列目の一番上から可能性をたどっていきます。
(3,0),(3,1),(3,2)
(3,2)に置けそうです。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-Q-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|---|-x-|---|---|3
  +-------------------+
  |---|---|-Q-|---|---|4
  +-------------------+
```

では４列目の移動できる可能性を上から順番にたどっていきます。
(4,0),(4,1),(4,2),(4,3)
(4,3)が置けそうです。

解が一つ見つかりました。

```
5: 3 2 4 1 0 
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-x-|-Q-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |-Q-|---|-x-|---|---|3
  +-------------------+
  |---|---|-Q-|---|---|4
  +-------------------+
```

さらに(4,4)への可能性も探索しますが、あたりなので移動できません。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-x-|-Q-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |-x-|---|-x-|---|---|3
  +-------------------+
  |-x-|---|-Q-|---|---|4
  +-------------------+
```
４列のクイーンは一番下まで到達しましたので、(3,2)のクイーンは(3,3)へ移動します。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|-x-|---|---|3
  +-------------------+
  |---|---|-Q-|---|---|4
  +-------------------+
```
ではあらためて `col4`列目のクイーンの移動の可能性を上から順番にたどります。
(4,0),(4,1),(4,2)
(4,2)が置けそうです。

これで一つ解が発見できました。

```
6: 2 3 4 1 0 
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-Q-|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|-x-|---|---|3
  +-------------------+
  |---|---|-Q-|---|---|4
  +-------------------+
```
続けて４列目のクイーンを下に移動してたどってみます。
(4,3),(4,4)もあたり
４列の移動候補はすべて潰しました。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|---|---|-Q-|0
  +-------------------+
  |-x-|-x-|---|-Q-|---|1
  +-------------------+ 
  |-x-|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |-x-|-Q-|-x-|---|---|3
  +-------------------+
  |-x-|---|-Q-|---|---|4
  +-------------------+
```

ここで３列目(3,3)のクイーンをひとつ下にずらします。
(3,4)はあたりで移動できませんね。
```
           ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|---|---|-Q-|0
  +-------------------+
  |---|-x-|---|-Q-|---|1
  +-------------------+ 
  |---|-x-|-x-|---|---|2 row(行) 
  +-------------------+ 
  |---|-x-|-x-|---|---|3
  +-------------------+
  |---|-x-|-Q-|---|---|4
  +-------------------+
```
３列目のクイーンの移動できる可能性はすべて潰しました。
さらに、矢印↓である `col2` 列目のクイーンの移動できる可能性はすべて潰しました。

ここで軸「↓」が一つ左にずれて `col1` 列が軸となり、(1,1)のクイーンをひとつ下に移動させます。
こうした動きが「バックトラック」と言われる理由です。

盤面は以下のとおりです。
```
               ↓
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-x-|---|1
  +-------------------+ 
  |---|---|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

そこで、２列(2,4)のクイーンが移動できる可能性をしらみつぶしに（ブルートフォース）たどっていきます。
(2,1)におけますね。
```
               ↓
        column(列)
   _4___3___2___1___0_
  |---|---|-x-|---|-Q-|0
  +-------------------+
  |---|---|-Q-|-x-|---|1
  +-------------------+ 
  |---|---|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```
では、３列目の可能性をたどります。
(3,3)に置けそうです。
```
               ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|-x-|---|-Q-|0
  +-------------------+
  |---|-x-|-Q-|-x-|---|1
  +-------------------+ 
  |---|-x-|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |---|-Q-|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```
では４列目の可能性をたどります。
(4,4)に置けました。
７つ目の解が発見できました。

```
7: 4 3 1 2 0 
               ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|-x-|---|-Q-|0
  +-------------------+
  |-x-|-x-|-Q-|-x-|---|1
  +-------------------+ 
  |-x-|-x-|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |-x-|-Q-|---|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```

では３列目の(3,3)を下に一つずらします。
```
               ↓
        column(列)
   _4___3___2___1___0_
  |---|-x-|-x-|---|-Q-|0
  +-------------------+
  |---|-x-|-Q-|-x-|---|1
  +-------------------+ 
  |---|-x-|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |---|-x-|---|---|---|3
  +-------------------+
  |---|-Q-|---|---|---|4
  +-------------------+
```
４列目の移動候補を上から順番にたどります。
(4,0),(4,1),(4,2),(4,3),
(4,3)に置けそうです。

ここで新たな解が発見できました。

```
8: 3 4 1 2 0 
               ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|-x-|---|-Q-|0
  +-------------------+
  |-x-|-x-|-Q-|-x-|---|1
  +-------------------+ 
  |-x-|-x-|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |-Q-|-x-|---|---|---|3
  +-------------------+
  |-x-|-Q-|---|---|---|4
  +-------------------+
```

ここからは解となる盤面情報表示しておきます。

```
9: 4 1 3 2 0 
               ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|-x-|---|-Q-|0
  +-------------------+
  |-x-|-Q-|-x-|-x-|---|1
  +-------------------+ 
  |-x-|---|-x-|-Q-|---|2 row(行) 
  +-------------------+ 
  |-x-|---|-Q-|---|---|3
  +-------------------+
  |-Q-|---|---|---|---|4
  +-------------------+
```

```
10: 1 4 3 2 0 
               ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|-x-|---|-Q-|0
  +-------------------+
  |-Q-|-x-|-x-|-x-|---|1
  +-------------------+ 
  |---|-x-|-x-|-Q-|---|2 row(行) 
  +-------------------+ 
  |---|-x-|-Q-|---|---|3
  +-------------------+
  |---|-Q-|---|---|---|4
  +-------------------+
```

```
11: 3 1 4 2 0 
               ↓
        column(列)
   _4___3___2___1___0_
  |-x-|-x-|-x-|---|-Q-|0
  +-------------------+
  |-x-|-Q-|-x-|-x-|---|1
  +-------------------+ 
  |-x-|---|-x-|-Q-|---|2 row(行) 
  +-------------------+ 
  |-Q-|---|-x-|---|---|3
  +-------------------+
  |---|---|-Q-|---|---|4
  +-------------------+
```

どうでしょうか？
ボード右側のクイーンよりも左側のクイーンが一生懸命に動いていることが判ります。
軸「↓」は右へ右へとずれていきますね。
この動きが「バックトラック」です。
次の章で本格的なバックトラックの完成となります。

左側のクイーンの移動候補がなくなったら右側のクイーンを一つおろして、左側のクイーンを候補の一番最初に戻し、可能性のある移動を探していましたね。


ソースの内容を深く理解する必要はありません。
どういう動きになるのかを知ることが重要です。
盤面の移動を何度も確認しておくのが良いです。
これからさらにどんどん複雑な動きとなります。
しっかりとクイーンの動きを理解してください。



## Ｎが５のときの計算方法
前回は、縦に一つのクイーン、いわゆる縦の効きだけを考慮しました。

そのＮ５の計算方法は

５＊５＊５＊５＊５＝３１２５
Ｎ＾５＝３１２５　となります。

一般的にこうしたブルートフォースの動きは
Ｎ＾Ｎ
と書きます。


今回は、横の効きも取り入れたことでステップ数は１２０となりました。
計算で出すと以下の通りとなります。

５＊４＊３＊２＊１＝１２０
５！＝１２０

一般的にこうしたバックトラックの動きは
Ｎ！
と書きます。


次回は、斜めの効きにも対応するバックトラックを説明します。
やっとそれが出来上がると、ブルートフォース（手当たりしだいの力まかせ探索）というロジックでエイトクイーンを解決したといえます。



"Ｎクイーン問題（４０）第七章　バックトラック Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

## バックトラック
前回の「ブルートフォース（力まかせ探索）」では、Ｎ個のクイーン配置が完了し、解の候補が生成される都度、`check_bluteForce()` 関数によって効きの判定を行いました。

Ｎ５の場合は、３１２５回効きの判定を行うことで、目に見えて処理が遅いこともわかりました。


## バックトラックについて
ブルートフォースでは、「Ｎ個のクイーン配置が完了し、解の候補が生成される都度、効きの判定を行う」ことをしてきましたが、バックトラックでは、解の候補が満たされ「なければ」、それ以上の探索を行わず、コマを１つ戻して「バックトラック」します。
以下の状態となれば、これ以上探索を行わないというロジックで、無駄を省いた探索法と言えます。

```
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1     # ここから先は探索しても無駄
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
        column(列)
   _4___3___2___1___0_
  |---|---|---|-Q-|-Q-|0     # ここから先は探索しても無駄
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

## 効き筋のチェック
効き筋のチェック関数は、ブルートフォースにもありましたが、バックトラックの効きチェック関数とは内容がちょっと異なります。

```python
#
# バックトラック版効き筋をチェック
def check_backTracking(row):
  global board
  for i in range(row):
    if board[i]>=board[row]:
      val=board[i]-board[row]
    else:
      val=board[row]-board[i]
    if board[i]==board[row] or val==(row-i):
      return 0
  return 1
```
board[row] まで配置した時点で、効きがないかどうかをチェックします。
board[0] から board[i] と board[row] を比較し、同一または斜め45度方向にクイーンが配置されていれば `0`(false) を返し、それらがひとつも無ければ`1`(true)を返します。



## バックトラックのプログラムソース
バックトラックのプログラムソースは以下のとおりです。

```python
#
# バックトラック
def backTracking(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if check_backTracking(row)==1:
        backTracking(row+1,size)
```

バックトラックとブルートフォース（力まかせ探索）の大きな違いは、最後まで配置してチェックするのではなく、クイーンを置くたびに効きチェックを行って、効きがあれば（解とならないとわかれば）状態から継続して探索を行わないといった点が異なります。

```python
    for col in range(size):
      board[row]=col
      if check_backTracking(row)==1:
        backTracking(row+1,size)
```




## ブルートフォースとバックトラックの違い

ブルートフォース版
for文で各行の何`col`目にクイーンを配置するかを決め、最後まで配置した場合は、`check_bluteForce()` を呼んで、効きであるかどうかを判定し、効きでなければ「解を発見した」として `((TOTAL++))`で、解個数をインクリメントしています。

```python
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      bluteForce(row+1,size)
```

バックトラック版
バックトラックでは、ブルートフォース（力まかせ探索）のように最後までクイーンを配置してから効きをチェックするのではなく、クイーンを置くたびに効きチェックを行い、効きがあればその状態からの探索を行わない点が異なります。
```python
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if check_backTracking(row)==1:
        backTracking(row+1,size)
```

次回は、バックトラックよりもさらに高速な「配置フラグ」の再帰・非再帰をご紹介します。
お楽しみに！



## プログラムソース
プログラムソースは以下のとおりです。

```python:02Python_backTracking.py
#!/usr/bin/env python3

# -*- coding: utf-8 -*-
"""
バックトラッキング版 Ｎクイーン

詳細はこちら。
【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから
https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題

エイト・クイーンのプログラムアーカイブ
Bash、Lua、C、Java、Python、CUDAまで！
https://github.com/suzukiiichiro/N-Queens

# 実行 
$ python <filename.py>

# 実行結果
1
 0 2 4 1 3
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
"""

#
# グローバル変数
MAX=21  # ボードサイズ最大値
TOTAL=0 # 解
board=[0 for i in range(MAX)] # ボード配列格納用
# 
# ボードレイアウト出力
def printRecord(size):
  global TOTAL
  global baord

  print(TOTAL)
  sEcho=""
  for i in range(size):
    sEcho+=" " + str(board[i])
  print(sEcho)
  print ("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  for i in range(size):
    print("|",end="")
    for j in range(size):
      if i==board[j]:
        print("O",end="")
      else:
        print(" ",end="")
      if j<(size-1):
        print("|",end="")
    print("|")
    if i in range(size-1):
      print("+",end="")
      for j in range(size):
        print("-",end="")
        if j<(size-1):
          print("+",end="")
      print("+")
  print("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  print("")
#
# バックトラック版効き筋をチェック
def check_backTracking(row):
  global board
  for i in range(row):
    if board[i]>=board[row]:
      val=board[i]-board[row]
    else:
      val=board[row]-board[i]
    if board[i]==board[row] or val==(row-i):
      return 0
  return 1
#
# ブルートフォース版効き筋チェック
def check_bluteForce(size):
  global board
  for r in range(1,size,1):
    for i in range(r):
      if board[i]>=board[r]:
        val=board[i]-board[r]
      else:
        val=board[r]-board[i]
      if board[i]==board[r] or val==(r-i):
        return 0
  return 1
#
# バックトラック
def backTracking(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if check_backTracking(row)==1:
        backTracking(row+1,size)
#
# ブルートフォース
def bluteForce(row,size):
  col=0
  global TOTAL
  global board
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      bluteForce(row+1,size)
#
# 実行
# bluteForce(0,5)  # ブルートフォース
backTracking(0,5) # バックトラッキング
#
```



## 実行結果
実行結果は以下の通りです。

```
1
 0 2 4 1 3 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
```


"Ｎクイーン問題（４１）第七章　配置フラグ Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)


## 第２章　エイトクイーン　配置フラグ

国内で最もきちんと説明していると（僕が勝手に）思っているＵＲＬを参照させてください。
僕が説明するよりももっと深みがあります。

[C++ゲーム解析プログラミング Nクイーン【前編】](https://tech.pjin.jp/blog/2020/06/12/nqueen-1)

（以下上記ＵＲＬの内容）
```
前章のバックトラッキング探索では、行の各カラムにクイーンを順に置いてみて、各行に配置しているクイーンの位置と比較してクイーンの効きチェックを行っていた。

が、この処理はfor文で各行を調べていたので、意外と処理が重い。
しかもノードを探索するたびに呼ばれるので、トータルの処理回数が多くなり、それに時間を要する。

そこで、配置可能かどうかを表す配置フラグを事前に用意しておき、それを参照するだけで配置可能かどうかを判定することにする。
フラグをチェックするだけなのでfor文でチェックするよりはるかに高速だ。
チェックするときは高速になるかもしれないが、その配置フラグを更新するのに時間が必を要するのではないかと心配されるかもしれない。

しかし、Ｎクイーンの場合、各行の配置候補箇所はＮ箇所なので、Ｎ回効きチェックを行う必要があるが、そのための配置フラグはそれ以前の状態で決まるので、更新は１回だけでよい。

つまり、配置フラグの方が処理回数自体が大幅に少なくなり、その結果高速になるということだ。

配置フラグとして、垂直・右上・右下方向についてクイーンが配置済みであることを表す
bool 型配列 col[], rup[], rdn[] を用意する（下図参照）。
```
![](nqueen_03.jpg)
[C++ゲーム解析プログラミング Nクイーン【前編】](https://tech.pjin.jp/blog/2020/06/12/nqueen-1)より。



ほれぼれしますね。

僕は、このページに出会わなかったら、第一章の配置フラグの認識のまま、言い換えればご認識のまま一生を終えていたかもしれません。

「知れば知るほど知らないことを知る」とはよく言ったものです。

第三章で紹介する予定の「ビットマップ」との橋渡しという位置づけの書籍が多いのですが、まだまだこの配置フラグの可能性はあるのではないかと思っています。

なんといっても、ビットマップになると、クイーンの位置を把握するにも、「もう何がなんだかわからなくなる」ので、枝刈りやロジックの最適化に二の足を踏んでしまうのです。

配置フラグ頑張れ！



## 効き筋のチェック
配置フラグ版では、これまでのブルートフォースやバックトラックで作成した別関数での効き筋チェック関数はありません。
すべて本体関数の中で処理します。


## 配置フラグ再帰版

配置フラグのロジックについて簡単に説明します。
```python
#
# ポストフラグ
def postFlag(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if(down[col]==0 and 
          right[row-col+size-1]==0 and
          left[row+col]==0):
        down[col]=1
        right[row-col+(size-1)]=1
        left[row+col]=1
        postFlag(row+1,size)
        down[col]=0
        right[row-col+(size-1)]=0
        left[row+col]=0
```

以下でクイーンを配置します。
```python
      board[row]=col
```


以下の部分で、下、右斜下、左斜下を配置済みとして「１」(true)をフラグとしてセットします。
```python
        down[col]=1
        right[row-col+(size-1)]=1
        left[row+col]=1
```

その直後で再帰を実行して`row`をインクリメントしながらボードの下方向へクイーンを配置していきます。
```python
        postFlag(row+1,size)
```

再帰が終わったら、`down[]`,`right[]`,`left[]`の配置フラグに「０」を代入してクリアし、空き地にします。
```python
        down[col]=0
        right[row-col+(size-1)]=0
        left[row+col]=0
```



## プログラムソース
プログラムソースは以下のとおりです。

```python:03Python_postFlag.py
#!/usr/bin/env python3

# -*- coding: utf-8 -*-
"""
ポストフラグ版 Ｎクイーン

詳細はこちら。
【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから
https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題

エイト・クイーンのプログラムアーカイブ
Bash、Lua、C、Java、Python、CUDAまで！
https://github.com/suzukiiichiro/N-Queens
Bash版ですが内容は同じです。


# 実行 
$ python <filename.py>

# 実行結果
1
 0 2 4 1 3
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
"""

#
# グローバル変数
MAX=21  # ボードサイズ最大値
TOTAL=0 # 解
board=[0 for i in range(MAX)] # ボード配列格納用
down=[0 for i in range(MAX)]  # 効き筋チェック
left=[0 for i in range(MAX)]  # 効き筋チェック
right=[0 for i in range(MAX)] # 効き筋チェック
# 
# ボードレイアウト出力
def printRecord(size):
  global TOTAL
  global baord

  print(TOTAL)
  sEcho=""
  for i in range(size):
    sEcho+=" " + str(board[i])
  print(sEcho)
  print ("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  for i in range(size):
    print("|",end="")
    for j in range(size):
      if i==board[j]:
        print("O",end="")
      else:
        print(" ",end="")
      if j<(size-1):
        print("|",end="")
    print("|")
    if i in range(size-1):
      print("+",end="")
      for j in range(size):
        print("-",end="")
        if j<(size-1):
          print("+",end="")
      print("+")
  print("+",end="")
  for i in range(size):
    print("-",end="")
    if i<(size-1):
      print("+",end="")
  print("+")
  print("")
#
# バックトラック版効き筋をチェック
def check_backTracking(row):
  global board
  for i in range(row):
    if board[i]>=board[row]:
      val=board[i]-board[row]
    else:
      val=board[row]-board[i]
    if board[i]==board[row] or val==(row-i):
      return 0
  return 1
#
# ブルートフォース版効き筋チェック
def check_bluteForce(size):
  global board
  for r in range(1,size,1):
    for i in range(r):
      if board[i]>=board[r]:
        val=board[i]-board[r]
      else:
        val=board[r]-board[i]
      if board[i]==board[r] or val==(r-i):
        return 0
  return 1
#
# ポストフラグ
def postFlag(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if(down[col]==0 and 
          right[row-col+size-1]==0 and
          left[row+col]==0):
        down[col]=1
        right[row-col+(size-1)]=1
        left[row+col]=1
        postFlag(row+1,size)
        down[col]=0
        right[row-col+(size-1)]=0
        left[row+col]=0
#
# バックトラック
def backTracking(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if check_backTracking(row)==1:
        backTracking(row+1,size)
#
# ブルートフォース
def bluteForce(row,size):
  col=0
  global TOTAL
  global board
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      bluteForce(row+1,size)
#
# 実行
# bluteForce(0,5)   # ブルートフォース
# backTracking(0,5) # バックトラッキング
# postFlag(0,5)     # ポストフラグ

#
```



## 実行結果
実行結果は以下の通りです。

```
1
 0 2 4 1 3 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
```

## ブルートフォースとバックトラック、配置フラグの特色と違い
ブルートフォース版
for文で各行の何`col`目にクイーンを配置するかを決め、最後まで配置した場合は、`check_bluteForce()` を呼んで、効きであるかどうかを判定し、効きでなければ「解を発見した」として `((TOTAL++))`で、解個数をインクリメントしています。
```python
#
# ブルートフォース
def bluteForce(row,size):
  col=0
  global TOTAL
  global board
  if row==size:
    if check_bluteForce(size)==1:
      TOTAL=TOTAL+1
      printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      bluteForce(row+1,size)
```

バックトラック版
ブルートフォース（力まかせ探索）のように最後まで配置して効きをチェックするのではなく、各行にクイーンを置くたびに効きチェックを行って、効きがあればその状態からの探索を行わない点が異なります。
```python
#
# バックトラック
def backTracking(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if check_backTracking(row)==1:
        backTracking(row+1,size)
```

配置フラグ版
計算済みの配置フラグは再帰によって「メモ」化されます。
この仕組みを利用して、`down[]`,`right[]`,`left[]` の３つの配列に１は配置済み、０は未配置（クリア）といった情報を与えます。
これにより再帰処理の中で、垂直下方向・対角線左右斜め方向にクイーンが配置済みかどうかをチェックすることが可能です。
どの方向にも配置済みで「なければ」、クイーンを配置し、次の `col` に進むというわけです。

配置フラグはバックトラックよりもさらに高速です。

```python
#
# ポストフラグ
def postFlag(row,size):
  global TOTAL
  col=0
  if row==size:
    TOTAL=TOTAL+1
    printRecord(size)
  else:
    for col in range(size):
      board[row]=col
      if(down[col]==0 and 
          right[row-col+size-1]==0 and
          left[row+col]==0):
        down[col]=1
        right[row-col+(size-1)]=1
        left[row+col]=1
        postFlag(row+1,size)
        down[col]=0
        right[row-col+(size-1)]=0
        left[row+col]=0
```

![](nqueen_03.jpg)
[C++ゲーム解析プログラミング Nクイーン【前編】](https://tech.pjin.jp/blog/2020/06/12/nqueen-1)より。




"Ｎクイーン問題（４２）第七章　ビットマップ Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

## ビットマップ
Ｎ×ＮのチェスボードのＮ個のクイーンの配置を、bitwise(ビット)で表したものが`bitmap`(ビットマップ)です。

## ビットマップの特徴
斜め方向にクイーンを配置したかどうかを、`left` `down` `right` といった `bit` フラグで表します。

大きなメリットは、
１．ビットマップであれば、シフト(`<<1` ,`>>1`)により高速にデータを移動できる。
２．配置フラグといったフラグ配列では、データの移動に O(N) の時間がかかるが、ビットマップであれば O(1)ですむ。
３．フラグ配列のように斜め方向に `2*N-1` の要素を用意する必要はなく `Nビット`で充分たりる。
４．ビットは初期値が０なので扱いやすい

デメリットとしては
２進数と１０進数により難読化が極まっている。

## ビットマップを言葉で説明すると・・・
４ｘ４のチェス盤を使ってみましょう。
チェス盤の各行は1つの2進数で表されますが、これは単なるビットの並びです。
ある行の一番左のマスにクイーンが置かれた場合、その行は8という数字で表されます。

```
+-+-+-+-+
|Q| | | |   1000
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```

この列の一番左には1があるので、2進数では1000となります。
左から3番目のマスにクイーンが置かれた場合、その列は2、つまり0010で表されます。

```
+-+-+-+-+
| | |Q| |   0010
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```

```
1: 0001
+-+-+-+-+
| | | |Q| 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+

2: 0010
+-+-+-+-+
| | |Q| | 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+

4: 0100
+-+-+-+-+
| |Q| | | 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+

8: 1000
+-+-+-+-+
|Q| | | | 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```

1、2、4、8以外の数字は、
```
9→1001
+-+-+-+-+
|Q| | |Q| 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```

```
15→1111
+-+-+-+-+
|Q|Q|Q|Q| 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```

のように、2つ以上のマスの占有を表すのに使うことができます。

コンフリクトの列が5(0101)の場合、左から1番目と3番目のマスが、他のクイーンとぶつからない唯一の空きマスであることを示し、この2マスに次のクイーンを配置することになります。

```
5→0101
+-+-+-+-+
| |Q| |Q| 
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```


## 実践、ビットマップ！
Ｎ５のボードレイアウト
```
 4 2 0 3 1  ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | |O| | 00010
+-+-+-+-+-+
| |O| | | | 01000
+-+-+-+-+-+
```

各行(row)の状態をbitwise（ビットワイズ）で表現します。
クイーンが置いてある位置の`bit`（ビット）をON（１）にします。

バックトラッキングは行(row=0)から下に向かって順に、クイーンが配置できた場所の`bit`をON（１）にして、その後rowが一つインクリメントします。

```
 4         ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```


```
 4 2       ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

```
 4 2 0     ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

```
 4 2 0 3   ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | |O| | 00010
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

```
 4 2 0 3 1  ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | |O| | 00010
+-+-+-+-+-+
| |O| | | | 01000
+-+-+-+-+-+
```



## 効き筋
次に、効き筋をチェックするためにさらに３つのビットフィールドを用意します。

```
left
+-+-+-+-+-+
| | | |Q| |
+-+-+-+-+-+
| | |L| | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

```
down
+-+-+-+-+-+
| | | |Q| |
+-+-+-+-+-+
| | | |D| |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

```
right
+-+-+-+-+-+
| | | |Q| |
+-+-+-+-+-+
| | | | |R|
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

左下に効き筋が進む(left)、真下に効き筋が進む(down)、右下に効き筋が進む(right)３つです。
その３つのビットフィールドをそれぞれ、left, down, right と呼ぶことにします。

まずは `row0` にクイーンを配置します。

```
Qの配置
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

次に、`row0` のビットフィールドから `row+1` 番目のビットフィールド、ようするにひとつ下の `row1` に探索を進め、

```
Qの配置
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | | | | ←ここ
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

`row0`のビットフィールドでクイーンが配置されている `bit` と、
```
Qの配置
+-+-+-+-+-+
| | | |Q| | 00010 = bit
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```



３つのビット `left` `down` `right` を使って、効き筋をチェックします。

効き筋は「ＯＲ演算」を使います。

ビット演算に関しては以下のリンクがおすすめです。
[ビット演算入門](https://qiita.com/Ingward/items/43acda931c8a62c70d2f)



leftはひとつ左に
```
left
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | |L| | | 00100
+-+-+-+-+-+
```

downはそのまま下に、
```
down
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | |D| | 00010
+-+-+-+-+-+
```

rightはひとつ右へ
```
right
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | | |R| 00001
+-+-+-+-+-+
```

こういったロジックで `row+1` 番目の効き筋をチェックします。



## bit（ビット）
クイーンの位置は「Q」です。
Qを配置した場合、そのposition（場所）は`bit`で表します。
`bit`（ビット）には、クイーンが配置されるとその位置が格納されるわけです。

以下の場合、`bit`は `00010` となります。

`row0`にQが配置された
```
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
```

ここで`bit`の操作が複雑となる原因のひとつ、
「00010」というクイーンの位置情報は、そのまま`bit`に格納されるのではありません。

`bit`には`00010` という場所の情報が格納されるわけですが、

「00001」の場合は「 1」
「00010」の場合は「 2」
「00100」の場合は「 4」
「01000」の場合は「 8」
「10000」の場合は「16」

が格納されることになります。

「はぁ？」

まず、
「00001」という並びは０と１でなりたつ表現方法で「２進数」といいます。
また、１０で桁上りをする表現方法はおなじみの「１０進数」といいます。

```
00010   　２進数
    2   １０進数 (00010を１０進数にすると 2 になる）
```



２進数を１０進数に置き換える早見表
```
10進数  128  64  32  16   8   4   2   1
 2進数    0   0   0   0   0   0   0   0
```

２進数 `00010` を１０進数に置き換えた値が知りたいは、早見表を使うと１０進数では `4` となります。

```
２進数を１０進数に置き換える早見表
10進数  16   8   4   2   1
 2進数   0   0   1   0   0
```

ということで、クイーンの位置が `00100` の場合は、`4` が `bit`に格納されます。

bashでは２進数を１０進数に変換して出力する方法が用意されています。
```
bash-3.2$ echo $(( 2#00001 ))
1
bash-3.2$ echo $(( 2#00010 ))
2
bash-3.2$ echo $(( 2#00100 ))
4
bash-3.2$ echo $(( 2#01000 ))
8
bash-3.2$ echo $(( 2#10000 ))
16
bash-3.2$
```

＃（シャープ）の前の数字は２進数であることを示しています。
２進数 `00100` の１０進数の値が知りたければ、次のようにします。
```
bash-3.2$ echo $(( 2#00100 ))
4
```


余談ですが（余談ということでもないのですが）、
Ｎが８の場合で、`00010000` というクイーン配置の場合
```
10進数  128  64  32  16   8   4   2   1
 2進数    0   0   0   1   0   0   0   0
```

早見表の通り、１０進数では「16」となります。
当然、bashでも求めることができます。
```
bash-3.2$ echo $(( 2#00010000 ))
16
```

さらに余談ですが（これは本当に余談）、ビットフィールドに複数の`bit`がON（１）である場合、例えば「00101010」のような場合は、以下のように計算します。
（（一行にクイーンが３つもある！！）

```
00101010 
10進数  128  64  32  16   8   4   2   1
 2進数    0   0   1   0   1   0   1   0
```

この場合は、`bit`が立っている（と言います）10進数の値をを足し合わせることで表現できます。

ビットが立っている（１となっている）のは、３２と８と２ですから、
```
32 + 8 + 2 = 42
```
となります。

bashでも確認してみます。
```
bash-3.2$ echo $(( 2#00101010 ))
42
```

おお、いい感じですね。着いてきていますか？



## Qの位置を確認
では、まずはQのposition（位置）を確認します。

```
Q
+-+-+-+-+-+
| | | |Q| | 00010=bit といいます。
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

Qのpositionは `00010` です。
１０進数では以下の早見表で見つけると良いです。

Qが置かれている`bit`の値は「00010」です
```
10進数  16   8   4   2   1
 2進数   0   0   0   1   0
```

10進数では「2」ですね。

まず、Qのpositionがわかりました。
Qのpositionを`bit`と言います。
通常、`bit`は変数名も`bit`とします。
```
bit = Q = 2#00010 = 2
```


## row + 1 のleftの効き筋をチェック）してみます

```
left
+-+-+-+-+-+
| | | |Q| | 00010 (`bit`)
+-+-+-+-+-+
| | |L| | | ←ここ
+-+-+-+-+-+
```

「L」は「Q」の真下（`row+1`）を左に一つずらした位置となります。
ビット演算では以下のようになります。Lはleftを表しています。
```
( left | bit)<<1
```

`( left | bit)` といった表現を「ＯＲ演算」と言います。

`left` にはこの段階では値が何も入っていませんので「0」となります。
要するに初期値「０」のまま計算します。

前項で求めたとおり、Qである`bit`は以下の通りでした。
```
bit = Q = 2#00010 = 2
```

`left`は、初期値「０」な訳ですから、
```
( left | bit )
(   0  |  2  )
```

という計算式になります。
bashで計算してみましょう。
```
bash-3.2$ echo $(( (2|0) ))
2
bash-3.2$
```

「２」とでました。
さらに左に一つシフト（<<1）してみます。
こうなりますね。
```
( left | bit )<<1
(   0  |  2  )<<1
```

bashで計算してみます。
```
bash-3.2$ echo $(( (2|0)<<1 ))
4
bash-3.2$
```

「４」とでました。
「４」の２進数はなんでしょう？
さっそく早見表で確認しましょう。
```
10進数  16   8   4   2   1
 2進数   0   0   1   0   0
```

`00100` という事ですね。

Qが置かれている場所が「00010」で、
Lは「00100」となったわけです。
図で表すと以下のとおりです。

```
left
+-+-+-+-+-+
| | | |Q| | 00010 (bit)
+-+-+-+-+-+
| | |L| | | 00100 (left|bit)<<1
+-+-+-+-+-+
```

ということで、Qの位置から左に一つずれているのがわかります。
Qを配置して`left`を使って左下の効きを簡単に求めることができました。
```
left  = ( left |  bit  )<<1
00100 = (  0   | 00010 )<<1
  4   = (  0   |   2   )<<1
```

`row0`にある Q の位置「00010」の、ひとつ下の `row1` の`left`の効き筋は `(left|bit)<<1` という計算式を用いて、「00100」となりました。
言い換えると、Qの位置を`bit`にして、`(left|bit)<<1`とすることで、ビットの位置を一つ左にシフトして、Qの`left`の効き筋を求めることができたということになります。


## row + 1 のdownの効き筋をチェック）してみます
leftの場合は、( left | bit )<<1 ということをしてQの位置から左に一つずらした位置を求めました。

downはleftのように左に一つずらしたりする必要はありません。
Qの位置からましたに下ろすだけですから値は同じなのです。
```
down
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | |D| | 00010 (down|bit)
+-+-+-+-+-+
```

```
down  = ( down |  bit  )
00010 = (  0   | 00010 )
  2   = (  0   |   2   )
```

bashでも確認してみます。
``` 
bash-3.2$ echo $(( (0|2) ))
2
bash-3.2$
```

down は 2#00010 ですので 2 です。


ここまでをまとめると以下のとおりです。
```
bit = Q = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0

left = (left|bit)<<1 = 2#00100 = 4
10進数  16   8   4   2   1
 2進数   0   0   1   0   0

down = (down|bit)    = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0
```

## row + 1 のrightの効き筋をチェック
rightはleft同様にシフトするわけですが、今度は右へシフトします。

```
right
+-+-+-+-+-+
| | | |Q| | 00010 (bit)
+-+-+-+-+-+
| | | | |R| 00001 (R)  (right|bit)>>1
+-+-+-+-+-+
```

```
right = ( right |  bit  )>>1
00010 = (   0   | 00010 )>>1
  1   = (   0   |   2   )>>1
```

bashでも確認してみます。
```
bash-3.2$ echo $(( (0|2)>>1 ))
1
bash-3.2$
```

ここまでをまとめると以下のとおりです。
```
bit = Q = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0

left = (left|bit)<<1 = 2#00100 = 4
10進数  16   8   4   2   1
 2進数   0   0   1   0   0

down = (down|bit)    = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0

right =(right|bit)>>1= 2#00001 = 1
10進数  16   8   4   2   1
 2進数   0   0   0   0   1
```



## マスクビット
ビットの使い方として最も多いものの 1 つがマスクビットです。なじみの深いもので言えば、IPアドレスのマスクビットや割り込み制御のマスクビットなどが挙げられます。多種多様な場面で使用されるマスクビットですが、基本的なアイディアは共通で、

・複数のフラグをまとめて立てる
・複数のフラグをまとめて消す
・必要な情報だけを取り出すために、マスクした部分の情報のみを取り出す
  といったものを効率良く実現するものです。
  現在のフラグ状態を表すビットを bit として、マスクビットを mask としたとき

|概要|実装|
|:-|:-|
|mask で表された部分のフラグをまとめて立てる|	bit ｜= mask |
|mask で表された部分のフラグをまとめて消す|	bit &= ~mask |
|mask で表された部分の情報のみを取り出したもの|	bit & mask|
|mask で表された部分のどれかのフラグが立っているかどうか|	if (bit & mask)|
|mask で表された部分のすべてのフラグが立っているかどうか|	if ((bit & mask) == mask)|



## mask（マスク） 
ここまでで３つのフラグを用いてQの効き筋を求めてきました。
```
left+down+right
+-+-+-+-+-+
| | | |Q| | 00010 (bit)
+-+-+-+-+-+
| | |L|D|R| 00111 (left|down|right)
+-+-+-+-+-+
```

３箇所の効き筋を演算子を使うと
```
(left|down|right) 
```
となり、こうした表現を「ＯＲ演算」と言います。



さて、`row + 1` 番目のビットフィールドを探索して、`left` `down` `right` の３つのbitフラグを「ＯＲ演算」したビットフィールドを作りました。

ＯＮ（１）になっている位置は効き筋に当たるので置くことができません。

`row`にQを配置して、
```
+-+-+-+-+-+  row
| | | |Q| |   0  今、自分はここにいて
+-+-+-+-+-+
| | | | | |   1
+-+-+-+-+-+
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

自分がいる `row` の一つしたの「row+1」のビットフィールドを探索するために、

```
+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+
|*|*|*|*|*|   1  この行(row)を順番に探索する
+-+-+-+-+-+
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

`left` `down` `right` の３つのフラグを使って、効きををチェックします。

`left` `down` `right` のいずれかがＯＮ（１）になっていたら効き筋に当たるから、その場所にはクイーンは配置できませんね。
という意味になります。

```
+-+-+-+-+-+  row
| | | |Q| |   0  bit  =      Q        = 2#00010 = 2
+-+-+-+-+-+      left = (left|bit)<<1 = 2#00100 = 4
|*|*|L|D|R|   1  down = (down|bit)    = 2#00010 = 2
+-+-+-+-+-+      right= (right|bit)>>1= 2#00001 = 1
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

そこで、上記の図の２箇所（アスタリスク＊の場所）がクイーンを配置することがが可能です。
この２箇所のアスタリスクは場所を簡単に得ることができます。

以下の通り、`left` は4 `down` は2 `right` は1 です。
```
bit  =      Q        = 2#00010 = 2

left = (left|bit)<<1 = 2#00100 = 4
down = (down|bit)    = 2#00010 = 2
right= (right|bit)>>1= 2#00001 = 1
```

効き筋 `(left|down|right)` は、次のように求めることができます。
``` 
(4|2|1)
```

と、なります。
bashで確認すると以下のとおりです。
```
bash-3.2$ echo $(( (4|2|1) ))
7
bash-3.2$
```

「７」となりました。これを２進数で表すと
```
bash-3.2$ bc <<<"ibase10;obase=2;7"
111
bash-3.2$
```

「１１１」ですから５ビットにすると
`2#00111` となります。

そこで、以下のアスタリスクの部分を求めるには「反転」という演算をおこないます。
```
+-+-+-+-+-+  row
| | | |Q| |   0  bit  =      Q        = 2#00010 = 2
+-+-+-+-+-+      left = (left|bit)<<1 = 2#00100 = 4
|*|*|L|D|R|   1  down = (down|bit)    = 2#00010 = 2
+-+-+-+-+-+      right= (right|bit)>>1= 2#00001 = 1
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

ここで、`2#11000`を求めることができれば、それがクイーンを配置することができる場所ということになります。

`2#11000` をbashで求めると`24`になります。
```
bash-3.2$ echo $(( 2#11000 ))
24
bash-3.2$
```

演算で求める場合は、「反転」という演算を使います。
(L|D|R) の 反転はチルダ「〜」を使います。
```python
~(L|D|R)
```

では、先に求めた「２４」になるかを確認してみましょう。

```
bash-3.2$ echo $(( (4|2|1) ))
7
bash-3.2$ echo $(( ~(4|2|1) ))
-8
bash-3.2$ 
```
なりませんね。。。

ここでmask(マスク）を使います。
maskとは、ビットフィールドのビットをすべて立てたものです。

```
+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
|M|M|M|M|M|   1  mask=2#11111
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

このmaskはPythonでも簡単に求めることができます。

```python
  mask=(1<<size)-1
```

Ｎ５の場合、２進数で求めると「３１」になります。
```
bash-3.2$ echo $(( 2#11111 ))
31
```

このmaskを使って
１．`left` `down` `right`の３つのビットを使って効きの場所を特定
```
(left|down|right)

+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
| | |L|D|R|   1  2#00111
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

２．反転させる 
```
# 2#00111
~(left|down|right) = -8
# 2#11000
```

２．maskですべての配置箇所のビットをＯＮ（１）にする
```
maskを使ってすべてのビットを立てる

size=5;
mask=(1<<size)-1

+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
|M|M|M|M|M|   1  2#11111 = 31
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

３．maskから~(left|down|right)を間引いた値を`bitmap`に格納
```
# クイーンが配置可能な位置を表す
bitmap=mask&~(left|down|right)

+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
|1|1|0|0|0|   1  2#11000 = 24
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+

 (left|down|right)  2#00111
~(left|down|right)  2#11000
mask                2#11111
----------------------------
AND                 2#11000  24 bitmap
```

おおお、２４になりました。
`bitmap`には２４が格納されるわけです。

これで効きのない場所を特定することができました。

１がクイーンを配置できる場所、いわゆる効き筋に当たらない場所ということになります。

あとは、効き筋に当たらない場所を順番にQを置いて行けばよいということになります。

順番にひとつひとつつまみ出して行く方法は後述します。


ここまでの処理をbashで書くと以下の通りになります。
```python:masktest.sh
#!/usr/bin/bash

mask=31; # 2#11111
left=4;  # 2#00100
down=2;  # 2#00010
right=1; # 2#00001

# (left|down|right)を反転させてmaskで間引く
# クイーンが配置可能な位置を表す
bitmap=$(( mask&~(left|down|right) ))
echo "$bitmap"  # 24

# 間引いた１０進数を２進数にして確認
bc<<<"ibase=10;obase=2;$bitmap"
# 11000
```

実行結果は以下のとおりです。
```
bash-3.2$ bash masktest.sh
11000
```


## ビットマップで肝となるところを重点的に

```python
# クイーンが配置可能な位置を表す
bitmap=mask&~(left|down|right)

# 一番右のビットを取り出す
bit=-bitmap&bitmap

# 配置可能なパターンが一つずつ取り出される
bitmap=bitmap&~bit

# Qを配置
board[row]=bit

# 再帰
Bitmap(size,row+1,(left|bit)<<1, (down|bit),(right|bit)>>1)
```

### bitmap=mask&~(left|down|right)
クイーンが配置可能な位置を表す

### bit=-bitmap&bitmap
while中の各繰り返しで、`bit` に、配置できる可能性と配置できない可能性をAND演算した結果を`bit`にセットしています。この結果、`bit` は、`bitmap` の最下位ビットを除いて、すべて`0`に設定し、Qを配置します。
もう少し噛み砕いて説明すると、単に最初の非ゼロビット（つまり最初に利用できる場所である１）を `bit` という変数に格納するだけです。
その `bit` （ビットが0010なら3列目）は、次のクイーンを置く場所となります。
つまり、bitmapの列を0にすることで、現在の位置が「取られた」ことを示すだけです。
こうすることで、whileループ中で、「取られた」場所を再度試す必要がなくなるということになります。

### bitmap=bitmap&~bit
配置可能なパターンが一つずつ取り出され、`bitmap` の最下位ビットを開放、次のループに備え、新しい最下位ビットを探索、再帰的な呼び出しを行い、次の行のビットフィールドである`bitmap` を更新します。
`bit` には、Qの場所を表す`1` が1つだけ入ったビットフィールが格納されています。
渡された競合情報と`OR演算` することで、再帰呼び出しの競合候補として追加されます。

### board[row]=bit # Qを配置
要するにQを配置するわけです。


### Bitmap(size,row+1,(left|bit)<<1, (down|bit),(right|bit)>>1)
ソースの中も最も混乱する行だと思います。
演算子 `>>1` と `1<<` は、ビットフィールド列すべてのビットをそれぞれ右、または左に1桁移動させるだけです。

つまり、`(left|bit)<<1` を呼ぶと、「leftとbitをOR演算で結合し、結果のすべてを1桁左に移動させる」という意味になります。

具体的には、`left` が `0001` （現在の行の4列目を通る右上から左下までの対角線が占有されていることを意味する）、`bit` が `0100`（現在の行の2列目にクイーンを置く予定であることを意味する）の場合、`(left|bit)` の結果は `0101` （現在の行の2列目にクイーンを置いた後、右上から左下までの対角線2本目と4本目が占有されることになります）。

ここで、`<<` 演算子を加えると、`(left|bit)<<1` となり、前の箇条書きで計算した `0101` を、すべて左に1つずつ移動させます。したがって、結果は `1010` となります。

さて、ここからが本当に難しいところなのですが、`bitmap_R` を再度呼び出す前に、なぜ1桁ずつ移動させるのでしょうか。

`row` が一番上の行から始まり、下に移動する場合、新しい行に移動するたびに、「占有対角線」のトラッキング変数である `left` と `right` を最新に保つ必要があります。

そこで、下のボートレイアウトを例にとると、
```
+-+-+-+-+  row
| | |Q| |   0  
+-+-+-+-+      
|Q| | | |   1  
+-+-+-+-+      
| | | |Q|   2
+-+-+-+-+
| |Q| | |   3
+-+-+-+-+
```
最上段3列目にクイーンを置くと、その瞬間の `left` `down` `right` はそれぞれ0010、0010、0010となる。

しかし、再び`bitmap_R`を呼び出して次の行に進むと、2行目では、2列目、3列目、4列目のすべてが、これまでに配置した1つのクイーンによって「攻撃されている」ことがわかります。
具体的には、3列目が占領され（`down`は0010）、2行目の4列目を通る左上から右下の対角線が占領され（だから`right`は0001）、2行目の2列目を通る右上から左下の対角線が占領されています（だから`left`は0100）。

```
+-+-+-+-+  row
| | |Q| |   0  
+-+-+-+-+      
| |x|x|x|   1  
+-+-+-+-+      
| | | | |   2
+-+-+-+-+
| | | | |   3
+-+-+-+-+
```
そのため、「行を下る」たびに対角線を移動させる必要があります。
そうしないと、どの対角線が「占有」されているかという知識が、現在の行に対して正しくなくなるからです。

上記の例からわかるように、`$(( ~(left|down|right ))` を計算すると`2#1000` となり、2行目の安全な場所は1列目のみであることがわかります。




## 斜めの効き筋
ビットマッププログラムのポイントは、斜めの利き筋のチェックをビット演算で行うことです。

```
    0 1 2 3 4
  *-------------
  | . . . . . .
  | . . . -3. .  0x02
  | . . -2. . .  0x04
  | . -1. . . .  0x08 (1 bit 右シフト)
  | Q . . . . .  0x10 (Q の位置は 4)
  | . +1. . . .  0x20 (1 bit 左シフト)  
  | . . +2. . .  0x40
  | . . . +3. .  0x80
  *-------------
```


この演算式の意味を理解するには、負の値がコンピュータにおける２進法ではどのように表現されているのかを知る必要があります。

負の値を２進数で表すと次のようになります。
```
 00000011   3
 00000010   2
 00000001   1
 00000000   0
 11111111  -1
 11111110  -2
 11111101  -3
```

正の値を負の値（補数と言います）にするときは、Ｒをビット反転してから＋１します。
```

 00000001   1
 11111110   反転
 11111111   -1 （1を加える）

 00000010   2
 11111101  反転
 11111110  -2  （１を加える）
```

加えるところがわかりにくいですね。
```
 00000001   1
```
 に１を加えると
```
 00000010   2
```
さらに１を加えると
```
00000011   3
```

と、なります。
１０進数の足し算と２進数のインクリメントは異なるところに注意が必要です。

ここで、 正の値２２と−２２をＡＮＤ演算すると以下のようになります。
```
     00010110   22
 AND 11101010  -22
------------------
     00000010
```

Ｎを２進法で表したときの一番下位のＯＮビットがひとつだけ抽出される結果が得られ、極めて簡単な演算によって１ビット抽出を実現させていることが重要です。

余談ですが、
bashで２進数を１０進数に変換するには以下のようにしました。
```
bash-3.2$ echo $(( 2#01000 ));
8
```

bashで１０進数を２進数に変換するには以下のようにします。
```
bash-3.2$ bc <<<"ibase=10;obase=10;8"
1000
```
余談終わり。


そこで下のようなwhile文を書けば、ループが bitmap のONビットの数の回数だけループすることになり、配置可能なパターンをひとつずつ全く無駄がループがなく生成されることになります。

```python
    bitmap=mask&~(left|down|right)
    while bitmap:
      bit=-bitmap&bitmap
      bitmap=bitmap&~bit
      board[row]=bit
      Bitmap(size,row+1,(left|bit)<<1, (down|bit),(right|bit)>>1)
```

`left` `down` `right` は、Qが配置されるたびに、その効き筋を足し合わせ、すべてのrowの効き筋に対応します。

再帰では、こうしたことをプログラマが意識することなく実現できるわけですが、非再帰の場合は、`left` `down` `right` を配列などで効き筋を覚えておく必要が出てきます。

それはどうとして猛烈にわかりやすい図がありました。
<img src=bitmap.jpg width=80%>




## 実行結果
実行結果は以下のとおりです。
```
1
 0 2 4 1 3
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

2
 0 3 1 4 2
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

3
 1 3 0 2 4
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

5
 2 0 3 1 4
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

7
 3 0 2 4 1
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

8
 3 1 4 2 0
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

9
 4 1 3 0 2
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

10
 4 2 0 3 1
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
```  





"Ｎクイーン問題（４３）第七章　ミラー Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

## ミラー
ミラー（鏡像）を用いてどのように改善できるのか
Ｎ５＝１０、Ｎ８＝９２といった、N-Queensの解が成立している場合、その鏡像（ミラー）も当然成立していることになります。

左右対称の鏡像の場合 この場合は、解がそれぞれ一つずつある。

```
+-+-+-+-+     +-+-+-+-+  
| | |Q| |     | |Q| | |
+-+-+-+-+     +-+-+-+-+
|Q| | | |     | | | |Q|
+-+-+-+-+     +-+-+-+-+
| | | |Q|     |Q| | | |
+-+-+-+-+     +-+-+-+-+
| |Q| | |     | | |Q| |
+-+-+-+-+     +-+-+-+-+
```


右の盤面は、左の盤面を左右対称にひっくり返しただけなのに、左盤面の解とは別の解として探索されカウントされます。

左のパターンが発見され１カウントできたら同時に、左右反転させて１カウントすればわざわざ探す必要がなくなります。


左右対称（鏡像）をつかって探索を効率的に進めるにはどうしましょう。


## 奇数と偶数
Ｎが偶数の場合は、最初の行の右半分、または左半分を除外（無視）すればよいのです。

`row0` いわゆる最初の行の左半分には置かない、
言い換えれば、一行目の右半分だけを使って解を探索する。一行目だけですからね！
```
+-+-+-+-+
|x|x| | |  左側を使わない
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```
```
+-+-+-+-+
|x|x| |Q|  右半分を使う
+-+-+-+-+  解があればカウントし、最後にカウントを倍にする。
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```
または
```
+-+-+-+-+
|x|x|Q| |  右半分を使う
+-+-+-+-+  解があればカウントし、最後にカウントを倍にする。 
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
| | | | |
+-+-+-+-+
```

Ｎが奇数の場合は、row0（最初の行）の奇数マスを2で割ることができないので、row0（最初の行）のクイーンが真ん中のマスにいない解はすべて、その半分を見つけて2をかければよいのです。

```
+-+-+-+-+-+        +-+-+-+-+-+  
|x|x| | |Q|        |x|x| |Q| | 中央を除く右側を使う。
+-+-+-+-+-+        +-+-+-+-+-+ 解があればカウントし、最後にカウントを倍にする
| | | | | |        | | | | | |
+-+-+-+-+-+        +-+-+-+-+-+
| | | | | |        | | | | | |
+-+-+-+-+-+        +-+-+-+-+-+
| | | | | |        | | | | | |
+-+-+-+-+-+        +-+-+-+-+-+
| | | | | |        | | | | | |
+-+-+-+-+-+        +-+-+-+-+-+
```


row0（最初の行）の真ん中のマスにクイーンがあるときも同じことができることが判明しました。
```
+-+-+-+-+-+
| | |Q| | |  
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```
row0（最初の行）の真ん中のマスにクイーンがある場合、row1（２行目）の真ん中のマスにクイーンがあることはありえません。
```
+-+-+-+-+-+
| | |Q| | |  
+-+-+-+-+-+
| | |Q| | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```


これで、row1（２行目）のマスのうち、まだ空いているマスは偶数個になりました！
ですので、row1（２行目）の残りのマスの半分を除外すればよいのです。
```
+-+-+-+-+-+
| | |Q| | |  
+-+-+-+-+-+
|x|x|x| | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

これで最初のクイーンが真ん中にある解のちょうど半分を見つけることができます。
これを、最初のクイーンが真ん中にない解の半分と足すと、全解のちょうど半分になり、これを2倍すると、出来上がりです！



## 図解すると
盤面が偶数の場合は、row0（最初の行）の半分だけを使って、解を倍にする。簡単！
盤面が奇数の場合は、以下を再確認。


row0（１行目）の左半分を除外
奇数Nの場合、これは真ん中のマスまでという意味であり、真ん中のマスは含まれない。このフィルターにより、今回のような解を見つけることができなくなります：

![](5-Queen-excluded-solution.png)

でも大丈夫、その鏡像を求めて、カウントを2倍するのですから：

![](5-Queen-excluded-Mirror.png)

しかし、これでは、１行目のクイーンが中央のマスにある解をダブルカウントしてしまうことになります。
次の解とその鏡像の解の両方がカウントされることになりますね。
また、1列目の真ん中のマスを除外してしまうと、どちらもカウントされません。
どちらか一方だけをカウントするようにしたいですね。

![](5-Queen-Middle-Solution.png)
![](5-Queen-Middle-Mirror.png)

そこで、２行目の左半分を除外する条件付きフィルタを追加し、このフィルタは１行目のクイーンが真ん中のマスにいるときだけ適用されるようにします。
２行目の真ん中のマスは、最初のクイーンと競合しているので、配置されることを気にする必要はありません。i
最初の行の真ん中にクイーンがある場合は、２行目の中央を除く右半分を使って解の探索し、解があれば２倍すればよいのです。

![](5-Queen-Exclude-2nd-row.png)


## 奇数・偶数共通通過ブロック解説

以下の部分は奇数・偶数に関わらず、いつでも通過するブロックです。
ですので、forの条件は size/2 ということで、盤の半分だけを探索対象とします。
```python
  for i in range(size//2):  # 奇数でも偶数でも通過
    bit=1<<i
    board[0]=bit            # １行目にＱを配置
    mirror_solver(size,1,bit<<1,bit,bit>>1)
```

## 奇数ブロック解説
```python
  if size%2:                # 奇数で通過
    # Pythonでの割り算の切り捨ては`//`です
    bit=1<<(size-1)//2
    board[0]=1<<(size-1)//2 # １行目の中央にＱを配置
    left=bit<<1
    down=bit
    right=bit>>1
    for i in range(limit):
      bit=1<<i
      mirror_solver(size,2,(left|bit)<<1,down|bit,(right|bit)>>1)
```

これは、、、なんでしょう。
```python
  limit=size%2 if size/2-1 else size/2
```

普通のif文に直すと以下のようになります。
```python
  if size%2 :
    limit=size//2-1
  else:
    limit=size//2
```

割り算の余りを切り捨てる「除算」は `//` ダブルスラッシュで行います。

`size%2` は？
ターミナルで実行して確認してみます。

```bash
bash $ echo $(( 5 % 2 )) 
     $ 1
```
```bash
bash $ echo $(( 6 % 2 )) 
     $ 0
```

１はtrueで０はfalseなので、奇数であるかどうか？ということになりますね。
ですので、

奇数だったら　limitに size/2-1 を代入
そうでなかったら limitに size/2 を代入　ということになります。


お、ここはなんでしょう。そうです。倍にしているところです。
`<<<1` というところがなんだかよくわかりませんが、coolですね。
数を倍にしたいときは、まよわず `<<1`を使って、難読化していきましょう。

```python
  TOTAL=COUNT2<<1          # 倍にする
```


ミラー　メインメソッド
```python
#
# ミラー
def Mirror(size):
  global COUNT2
  mask=(1<<size)-1
  bit=0
  """
  if size%2 :
    limit=size//2-1
  else:
    limit=size//2
  """
  limit=size%2 if size/2-1 else size/2
  # pythonでは割り算の切り捨ては`//`です
  for i in range(size//2):  # 奇数でも偶数でも通過
    bit=1<<i
    board[0]=bit            # １行目にＱを配置
    mirror_solver(size,1,bit<<1,bit,bit>>1)
  if size%2:                # 奇数で通過
    # Pythonでの割り算の切り捨ては`//`です
    bit=1<<(size-1)//2
    board[0]=1<<(size-1)//2 # １行目の中央にＱを配置
    left=bit<<1
    down=bit
    right=bit>>1
    for i in range(limit):
      bit=1<<i
      mirror_solver(size,2,(left|bit)<<1,down|bit,(right|bit)>>1)
  TOTAL=COUNT2<<1          # 倍にする
  print("size:",size,"TOTAL:",TOTAL,"COUNT2:",COUNT2)
```

## ロジック部分解説
実は、ロジック部分は、これまでのビットマップの再帰ソースと同じなのです。
結局、ミラーは偶数であるか、奇数であるかの判別を行っているに過ぎません。
偶数であれば、半分、奇数であれば、中央を除く半分、中央に置かれた場合は、２段めの中央を除く半分を配置可能エリアとして、解があれば２倍にします。

```python
#
# ミラーソルバー
def mirror_solver(size,row,left,down,right):
  global COUNT2
  global TOTAL
  mask=(1<<size)-1
  bit=0
  bitmap=0
  if row==size:
    COUNT2+=1
    TOTAL=TOTAL+1 # ボードレイアウト出力用
    printRecord_bitmap(size,1)
  else:
    # Ｑが配置可能な位置を表す
    bitmap=mask&~(left|down|right)
    while bitmap:
      bit=-bitmap&bitmap  # 一番右のビットを取り出す
      bitmap=bitmap^bit   # 配置可能なパターンが一つずつ取り出される
      board[row]=bit      # Ｑを配置
      mirror_solver(size,row+1,(left|bit)<<1,down|bit,(right|bit)>>1)
```





"Ｎクイーン問題（４４）第七章　対象解除法 Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

## 対象解除法について
まず、Ｎが小さな盤面で考えていきます。
以下、順に見て理解を深めてもらえればと思います。


##対象解除法について（Ｎ２版）
ひとつの解には、盤面を90度・180度・270度回転、及びそれらの鏡像の合計8個の対称解が存在します。

```
  原型   90度  180度   270度
  １２   ４１   ３４   ２３
  ４３   ３２   ２１   １４
  
      上の行を左右反転                     
  ２１   １４   ４３   ３２
  ３４   ２３   １２   ４１
```

上図左上がユニーク解です。
```
  原型（ユニーク解）
  １２ 
  ４３ 
```

１行目はユニーク解を90度、180度、270度回転したものです。
```
  原型   90度  180度   270度
  １２   ４１   ３４   ２３
  ４３   ３２   ２１   １４
```

2行目は1行目のそれぞれを左右反転したものです。
```
      上の行を左右反転                     
  ２１   １４   ４３   ３２
  ３４   ２３   １２   ４１
```

2行目はユニーク解を左右反転、対角反転、上下反転、逆対角反転したものとも解釈できます。
ただし、回転・線対称な解もあるので注意が必要です。

対称的な解を除去し、ユニーク解のみを求める方法はいくつかあります。
ここでは、一つの解には８つのパターンが存在することを覚えておいてください。


## 対象解を導き出す２つの方法
対象解を導き出す方法として、
１．解が見つかるたびに回転・対象をチェック
２．解のすべてを保存して、保存された解の回転・対象をチェック


最小解選択法 
解がひとつみつかるとすべての対称解を生成、 状態を数値とみなして最も小さいもののみを解とする方法。
最も最適と言われています。

最小選択法よりも劣る方法
解全てを保存しておき、新しい解が発見されるたびに対称形が無いかどうかを調べる方法。
保存領域を必要とするし、比較時に対称形を生成する必要があります。


## 対象解除法（Ｎ５版）
全探索によって得られたある１つの解が、回転・反転などによる本質的に変わることのない変換によって他の解と同型となるものが存在する場合、それを別の解とはしないとする解の数え方で得られる解を「ユニーク解」といいます。

ユニーク解とは、全解の中から回転・反転などによる変換によって同型になるものどうしをグループ化することを意味しています。

```
グループ１:
+-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | |Q| | | |
+-+-+-+-+-+  +-+-+-+-+-+
|Q| | | | |  | | | | |Q|
+-+-+-+-+-+  +-+-+-+-+-+
| | |Q| | |  | | |Q| | |
+-+-+-+-+-+  +-+-+-+-+-+
| | | | |Q|  |Q| | | | |
+-+-+-+-+-+  +-+-+-+-+-+
| |Q| | | |  | | | |Q| |
+-+-+-+-+-+  +-+-+-+-+-+

グループ２:
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| | | | |Q|  |Q| | | | |  | | |Q| | |  | | |Q| | |  | | | |Q| |  | |Q| | | |  |Q| | | | |  | | | | |Q|  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| | |Q| | |  | | |Q| | |  |Q| | | | |  | | | | |Q|  | |Q| | | |  | | | |Q| |  | | | |Q| |  | |Q| | | |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
|Q| | | | |  | | | | |Q|  | | | |Q| |  | |Q| | | |  | | | | |Q|  |Q| | | | |  | |Q| | | |  | | | |Q| |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| | | |Q| |  | |Q| | | |  | |Q| | | |  | | | |Q| |  | | |Q| | |  | | |Q| | |  | | | | |Q|  |Q| | | | |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| |Q| | | |  | | | |Q| |  | | | | |Q|  |Q| | | | |  |Q| | | | |  | | | | |Q|  | | |Q| | |  | | |Q| | |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
```

ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、この解はユニーク解ではないという定まった判定方法はありません。
ユニーク解であるかどうかの判断はユニーク解の個数を数える目的の為だけにあります。
どのような定義をしたとしてもユニーク解の個数それ自体は変わりません。

Ｎクイーン問題は、正方形のボードで形成されるので、回転・反転による変換パターンはぜんぶで８通りあります。

だからといって「全解数＝ユニーク解数×８」と単純にはいきません。
ひとつのグループの要素数が必ず８個あるとは限らないのです。

Ｎ＝５の例では２つのグループがあり、要素数が２個のグループ、要素数が８個のグループがあります。
結論から言うと、Ｎ＝５の全解は１０個で、ユニーク解は２個です。


## ユニーク解を判定するための定義
各行のクイーンが左から何番目にあるかを調べて、最上段の行(row)から下の行(row)へ順番に列挙します。
そしてそれをＮ桁の数値として見た場合に「最大値」となるものをユニーク解とします。
このＮ桁の数を以後は「ユニーク判定値」と呼ぶことにします。
```
 0 1 2 3 4 
+-+-+-+-+-+  
| | | | |Q|    4
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
|Q| | | | |    0  ----> 4 2 0 3 1 （ユニーク判定値）
+-+-+-+-+-+             数が大きい方をユニークとみなす 
| | | |Q| |    3
+-+-+-+-+-+  
| |Q| | | |    1 
+-+-+-+-+-+  

 0 1 2 3 4     左右反転！
+-+-+-+-+-+  
|Q| | | | |    0
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
| | | | |Q|    4  ----> 0 2 4 1 3 
+-+-+-+-+-+            数が小さいのでユニーク解とはしません 
| |Q| | | |    1
+-+-+-+-+-+  
| | | |Q| |    3 
+-+-+-+-+-+  
```

探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定するには、「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるかを調べる」ことになります。

Ｎ２の場合の８通りの変換
```
  原型   90度  180度   270度
  １２   ４１   ３４   ２３
  ４３   ３２   ２１   １４
  
      上の行を左右反転                     
  ２１   １４   ４３   ３２
  ３４   ２３   １２   ４１
```

結論から先にいえば、ユニーク解とは成り得ないことが明確なパターンを探索中に切り捨てる「枝刈り」を組み込むことにより、３通りの変換を試みるだけでユニーク解の判定が可能になります。


## 枝刈り
先ず最上段の行(row)のクイーンの位置に着目します。
その位置が左半分の領域にあればユニーク解には成り得ません。
何故なら左右反転によって得られるパターンのユニーク判定値の方が確実に小さくなるからです。
```
 0 1 2 3 4     
+-+-+-+-+-+  
|Q| | | | |    0
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
| | | | |Q|    4  ----> 0 2 4 1 3 
+-+-+-+-+-+            数が小さいのでユニークとはしません
| |Q| | | |    1
+-+-+-+-+-+  
| | | |Q| |    3 
+-+-+-+-+-+  

 0 1 2 3 4     左右反転！
+-+-+-+-+-+  
| | | | |Q|    4
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
|Q| | | | |    0  ----> 4 2 0 3 1 （ユニーク判定値）
+-+-+-+-+-+             数が大きい方をユニークとみなす 
| | | |Q| |    3
+-+-+-+-+-+  
| |Q| | | |    1 
+-+-+-+-+-+  
```


Ｎが奇数の場合に中央にあった場合はどうでしょう。
```
+-+-+-+-+-+  
| | |Q| | |    2
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
```

これもユニーク解には成り得ません。
何故なら仮に中央にあった場合、それがユニーク解であるためには少なくとも他の３辺におけるクイーンの位置も中央になければならず、それは互いの効き筋にあたるので解になりえないからです。
```
+-+-+-+-+-+  
| | |Q| | |    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
|Q| | | |Q|       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | |Q| | |      
+-+-+-+-+-+  
```

最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
```
+-+-+-+-+-+  
| | | |Q|Q|    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
```

次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
```

他の３つの角にクイーンを置くことはできないので、
```
+-+-+-+-+-+  
|Q| | | |Q|    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
|Q| | | |Q|      
+-+-+-+-+-+  
```

ユニーク解であるかどうかを判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになります。
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| | | |/| |      
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| | | |     
+-+-+-+-+-+  
|/| | | | |      
+-+-+-+-+-+  
```

突き詰めれば、上から２行目(row1)のクイーンの位置が右から何番目にあるかと、
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| |Q| |/| |  ←
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| | | |     
+-+-+-+-+-+  
|/| | | | |      
+-+-+-+-+-+  
```
右から２列目のクイーンの位置が上から何番目にあるかを比較するだけで判定することができます。
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| |Q| |/| |      
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| |Q| |  ←    
+-+-+-+-+-+  
|/| | | | |      
+-+-+-+-+-+  
```
この２つの値が同じになることはないからです。
```
       3 0
+-+-+-+-+-+  
| | | | |Q| 0
+-+-+-+-+-+  
| |Q| |/| | 3    上から２行目のクイーンの位置が右から４番目にある。
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| |Q| |  ←  右から２列目のクイーンの位置が上から４番目にある。
+-+-+-+-+-+      しかし、互いの効き筋にあたるのでこれは有り得ない。 
|/| | | | |      
+-+-+-+-+-+  
```
結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得られる解は総てユニーク解であることが保証されます。
```
+-+-+-+-+-+  
| | | |X|Q| 
+-+-+-+-+-+  
| |Q| |X| | 
+-+-+-+-+-+  
| | | |X| |       
+-+-+-+-+-+             
| | | |Q| | 
+-+-+-+-+-+ 
| | | | | |      
+-+-+-+-+-+  
```

次に右端以外にクイーンがある場合を考えてみます。
オリジナルがユニーク解であるためには先ず下図の X への配置は禁止されます。
よって、その枝刈りを先ず入れておきます。
```
+-+-+-+-+-+-+-+-+  
|X|X| | | |Q|X|X| 
+-+-+-+-+-+-+-+-+  
|X| | | | | | |X| 
+-+-+-+-+-+-+-+-+  
| | | | | | | | |       
+-+-+-+-+-+-+-+-+             
| | | | | | | | | 
+-+-+-+-+-+-+-+-+ 
| | | | | | | | |      
+-+-+-+-+-+-+-+-+  
| | | | | | | | |
+-+-+-+-+-+-+-+-+
|X| | | | | | |X|
+-+-+-+-+-+-+-+-+
|X|X| | | | |X|X|
+-+-+-+-+-+-+-+-+
```

次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。
```
+-+-+-+-+-+-+-+-+  
|X|X| | | |Q|X|X| 
+-+-+-+-+-+-+-+-+  
|X| | | |x|x|x|X| 
+-+-+-+-+-+-+-+-+  
|C| | |x| |x| |x|       
+-+-+-+-+-+-+-+-+             
| | |x| | |x| | | 
+-+-+-+-+-+-+-+-+ 
| |x| | | |x| | |      
+-+-+-+-+-+-+-+-+  
|x| | | | |x| |A|
+-+-+-+-+-+-+-+-+
|X| | | | |x| |X|
+-+-+-+-+-+-+-+-+
|X|X|B| | |x|X|X|
+-+-+-+-+-+-+-+-+
```
従って、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいことになります。


## ユニーク解を数える
これまでの考察はユニーク解の個数を求めるためのものでした。
全解数を求めるにはユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。
したがって探索時間を犠牲にしてしまうことになります。
そこで「ユニーク解の個数から全解数を導いてしまおう」という試みが考えられます。
これは、左右反転（前章のミラー）によるパターンの探索を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。
そしてそれを実現させるには「ユニーク解が属するグループの要素数はいくつあるのか」という考察が必要になってきます。

最初に、クイーンが右上角にあるユニーク解を考えます。
```
+-+-+-+-+-+  
| | | | |Q| 
+-+-+-+-+-+  
| | | | | | 
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | | 
+-+-+-+-+-+ 
| | | | | |      
+-+-+-+-+-+  
```

斜軸で反転したパターンがオリジナルと同型になることは有り得ないことと(×２)、
```
+-+-+-+-+-+  +-+-+-+-+-+ 
| | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q|/| |  | | | |/| | 
+-+-+-+-+-+  +-+-+-+-+-+ 
| | |/| | |  | | |/|Q| | 
+-+-+-+-+-+  +-+-+-+-+-+            
| |/| | | |  | |/| | | | 
+-+-+-+-+-+  +-+-+-+-+-+ 
|/| | | | |  |/| | | | |     
+-+-+-+-+-+  +-+-+-+-+-+ 
```
右上角のクイーンを他の３つの角に写像させることができるので(×４)、
```
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | |Q|  | | | | | |  | | | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | | |  | | | | | |  | | | | | |  | | | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | | |  | | | | | |  | | | | | |  | | | | | |      
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+            
| | | | | |  | | | | | |  | | | | | |  | | | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | | |  | | | | |Q|  |Q| | | | |  | | | | | |     
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
```

このユニーク解が属するグループの要素数は必ず８個(＝２×４)になります。

次に、クイーンが右上角以外にある場合は少し複雑になります。

(1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルから180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリジナルと同型になる。	

90度回転させても同じ場合は
```
+-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | | | |Q| | 
+-+-+-+-+-+  +-+-+-+-+-+ 
|Q| | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q| | |  | | |Q| | | 
+-+-+-+-+-+  +-+-+-+-+-+            
| | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+ 
| |Q| | | |  | |Q| | | |     
+-+-+-+-+-+  +-+-+-+-+-+ 
```

さらに90度回転（原型から180度回転）させても
```
                 さらに90度回転
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | | | |Q| |  | | | |Q| | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
|Q| | | | |  |Q| | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q| | |  | | |Q| | |  | | |Q| | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+            
| | | | |Q|  | | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| |Q| | | |  | |Q| | | |  | |Q| | | |     
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
```
さらに90度回転（原型から270度回転）させても同じ！
```
                               さらに90度回転
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | | | |Q| |  | | | |Q| |  | | | |Q| | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
|Q| | | | |  |Q| | | | |  |Q| | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q| | |  | | |Q| | |  | | |Q| | |  | | |Q| | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+            
| | | | |Q|  | | | | |Q|  | | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| |Q| | | |  | |Q| | | |  | |Q| | | |  | |Q| | | |     
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 


```
(2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナルとは異なる。
ただし、180度回転させた場合はオリジナルと同型になることも有り得る。	


## ユニーク数から全解を求める

１．クイーンが右上角にある場合、ユニーク解が属するグループの要素数は必ず８個(＝２×４)

２．クイーンが右上角以外にある場合、
  (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルから180度回転)させても、
  さらに90度回転(オリジナルから270度回転)させてもオリジナルと同型になる。	
  こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパターンを加えて２個しかありません。

  (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナルとは異なる。
  ただし、180度回転させた場合はオリジナルと同型になることも有り得る。	
  こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同型になる場合は４個(左右反転×縦横回転)

  (3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)

  １の場合は、解の数ｘ８
  ２−（１）の場合は、解の数ｘ２
  ２−（２）の場合は、解の数ｘ４
  ２−（３）の場合は、解の数ｘ８
  それぞれのグループの解の数にグループのパターン数をかけ合わせた数の総計が全解となります。
  ひとつひとつのユニーク解が上のどの種類に該当するのかを調べることにより全解数を計算で導き出すことができるのです。


## 対象解除法について
対象解除法のソースは４つの関数で構成されています。

１．printRecord()
  解を発見するたびにボードレイアウトを表示します。
  以降、新しい枝刈りポイントを発見するためにも使います。
  board[]を使ってＱの位置を確認するのに役立ちます。

２．symmetryOps()
  対象解除を行うロジックメソッドです。
  以下のロジックが同梱されています。
  
  １．クイーンが右上角にある場合、ユニーク解が属するグループの要素数は必ず８個(＝２×４)
  ２．クイーンが右上角以外にある場合、
```
(1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルから180
度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリジナルと同
型になる。
こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパター ンを
加えて２個しかありません。
(2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナルとは
  異なる。ただし、180度回転させた場合はオリジナルと同型になることも有り得る。
こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同型になる
  場合は４個(左右反転×縦横回転)
(3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)
```

３．backTrack()
  再帰ロジックで作られています。
  右上角にＱが配置されているかいないかで判定処理が分岐されます。
  その判定処理に従って、見合った枝刈りが行われます。

４．symmetry()
  本体メソッドです。
  こちらのメソッドでは、Ｑが角に配置されている場合、そうでない場合を分岐して３のbackTrack()に渡します。


## symmetry()メソッド
### 角にＱがある時の処理
symmetry()メソッドは、Ｑが角にあるかどうかを判定し、適切にbackTrack()に処理を渡します。

では上から順番に見ていきます。
とても大切なことなのですが、グローバル変数の初期化を行います。
```python
  TOTAL=UNIQUE=COUNT2=COUNT4=COUNT8=0
```

角にＱがある時のボードのイメージは以下のとおりです。

```
  角にQがある時の処理
    +-+-+-+-+-+  
    | | | | |Q| 
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

MASKについてですが、こちらはrow全体にビットを立てて配置済みとするフィルタのことです。

Ｎ５の場合、 １０進数では３１、２進数では 11111 となります。

```python
mask=(1<<size)-1
    +-+-+-+-+-+  
    |M|M|M|M|M|  mask=(1<<size)-1
    +-+-+-+-+-+  $(( (1<<5)-1 )):31
    | | | | | |  $(( 2#11111 )) 
    +-+-+-+-+-+  $ 31
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  ```

bashでは以下のようにすると２進数を１０進数に変換して表示することができます。
```bash
$ echo $(( 2#11111 ))
$ 31
```

TOPBITは左上角にビットを立てたものです。
```python
  TOPBIT=1<<(size-1)
    +-+-+-+-+-+  
    |T| | | | |  TOPBIT=1<<(size-1)
    +-+-+-+-+-+  $(( (1<<(5-1) )):16 
    | | | | | |  $(( 2#10000 )) 
    +-+-+-+-+-+  $ 16 
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

ENDBITはTOPBITの１つ右にビットを立てたものです。現在はまだ初期値０のままです。
後述しますがENDBITは、

```python
ENDBIT=LASTMASK=SIDEMASK=0
```
となります。

```python
  ENDBIT=LASTMASK=SIDEMASK=0
    ０は何も置かない（なにもはじまってない）
    +-+-+-+-+-+  
    |T|E| | | |  0#01000
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

配列BOUND1とBOUND2を初期化して
Ｑを右上角に配置します。

```python
  BOUND1=2
  BOUND2=0
```

```
    +-+-+-+-+-+  右角から１つ左から開始
    | | | |B| |  BOUND1は右から左へシフト
    +-+-+-+-+-+   
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```
```
    +-+-+-+-+-+  左角から１つ右から開始
    | |B| | | |  BOUND2は左から右へシフトします。
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

ここはすごく重要で、row[0]の１というのは右上の角のことを意味します。ですので、「Ｑを右上角に配置した」ということになります。

```python
  board[0]=1       # Qを右上角に配置
```

ここで、rowは２行目の処理に入ります。
というのも、１行目は右上角にＱを配置したので次に進んだわけです。

その後、以下の行は「２行目の真ん中にＱを配置する」という意味となります。
```python
      bit=1<<BOUND1
```

イメージでは以下のとおりです。
```python
       Ｎ５の場合、BOUND1は２と３になる
        1<<BOUND1  ２行目は真ん中に置く
        +-+-+-+-+-+  
        | | | | |Q|  1#00001
        +-+-+-+-+-+  
        | | |B| | |  BOUND1=2 4#00100
        +-+-+-+-+-+  $(( 1<<2 ))
        | | | | | |  $ 4
        +-+-+-+-+-+  1->2->4               
        | | | | | | 
        +-+-+-+-+-+ 
        | | | | | |      
        +-+-+-+-+-+  
```

さらに、処理の中でBOUND1は左に１つシフトします。
```python
        1<<BOUND1    ２行目は真ん中の次に置く
        +-+-+-+-+-+  
        | | | | |Q|  1#00001
        +-+-+-+-+-+  
        | |B| | | |  BOUND1=3 8#01000
        +-+-+-+-+-+  $(( 1<<3 ))
        | | | | | |  $ 8
        +-+-+-+-+-+  1->2->4->8             
        | | | | | | 
        +-+-+-+-+-+ 
        | | | | | |      
        +-+-+-+-+-+  
```

### 角にＱがない時の処理
TOPBITは先程も書いたとおり、左上角にビットを立てた状態を示します。
```python
  TOPBIT=1<<(size-1)
    +-+-+-+-+-+  
    |T| | | | | TOPBIT=1<<(size-1)
    +-+-+-+-+-+ $(( 2#10000 )) 
    | | | | | | $ 16 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

ENDBITは、TOPBITの１つ右にビットを立てた状態です。
```python
  ENDBIT=TOPBIT>>1
    +-+-+-+-+-+  
    |T|E| | | | ENDBIT=TOPBIT>>1
    +-+-+-+-+-+ $(( 2#01000 )) 
    | | | | | | $ 8
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

SIDEMASKは行の両サイドの角にビットを立てた状態を示します。
```python
  SIDEMASK=TOPBIT|1
    +-+-+-+-+-+  
    |S| | | |S| SIDEMASK=TOPBIT|1
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

LASTMASKもSIDEMASK同様左右の角のビットを立てた状態を示します。ただ使いみちとしては、上記の状態でも使えるわけですが、
```python
  LASTMASK=TOPBIT|1
    +-+-+-+-+-+  
    |L| | | |L| LASTMASK=TOPBIT|1
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

こういうシチュエーションで使います。
```python
  LASTMASK=$(( TOPBIT|1 )); 
    +-+-+-+-+-+  
    | | | | | | LASTMASK=$(( TOPBIT|1 ))
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    |L| | | |L|      
    +-+-+-+-+-+  
```

ENDBITは左角の１つ手前から右へシフトするビットです。
```python
    ENDBIT=ENDBIT>>1
      +-+-+-+-+-+  
      |T|E| | | | ENDBIT=TOPBIT>>1
      +-+-+-+-+-+ $(( 2#01000 )) 
      | | | | | | $ 8
      +-+-+-+-+-+  
      | | | | | |       
      +-+-+-+-+-+             
      | | | | | | 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
           ↓
      +-+-+-+-+-+  
      |T| |E| | | ENDBIT=ENDBIT>>1
      +-+-+-+-+-+ $(( 2#00100 )) 
      | | | | | | $ 4
      +-+-+-+-+-+  
      | | | | | |       
      +-+-+-+-+-+             
      | | | | | | 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
```

LASTMASKに代入されるビットは以下のイメージとなります。使いみちはLASTMASKと似ていますが、
```python
    +-+-+-+-+-+  
    |L|L| |L|L| LASTMASK=LASTMASK<<1 | LASTMASK | LASTMASK>>1
    +-+-+-+-+-+ $(( 2#11011 )) 
    | | | | | | $ 27
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

こういったシチュエーションにも使います。
```python
    +-+-+-+-+-+  
    | | | | | | LASTMASK=LASTMASK<<1 | LASTMASK | LASTMASK>>1
    +-+-+-+-+-+ $(( 2#11011 )) 
    | | | | | | $ 27
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    |L|L| |L|L|      
    +-+-+-+-+-+  
```


##  backTrack()メソッド
### 角にＱがある時の処理
このメソッドでは、角にＱがある場合の処理、ない場合の処理の分岐があり、その分岐の中で、`((COUNT8++))`であったり、`symmetryOps`といった対象解除の処理へ進んだり、はたまた「枝刈り」をしたりと、濃厚なメソッドです。

では、順番に見ていきます。

ここは、Ｑが角にある場合の処理で、rowが最終行までたどり着いた（配置できた）場合の処理となります。グループの要素数は必ず８あるわけですので、あとから８倍する`COUNT8`をインクリメントします。
```python
  """
  １．クイーンが右上角にある場合、ユニーク解が属する
  グループの要素数は必ず８個(＝２×４)
  """
  if row==(size-1):
    if bitmap :
      board[row]=bitmap
      if DISPLAY :
        printRecord_bitmap(size,1)
      COUNT8+=1
```

次は、Ｑが角にある場合の処理で、
        上から２行目のクイーンの位置が左から何番目にあるかと、
        右から２列目のクイーンの位置が上から何番目にあるかを、
        比較するだけで判定します。
        具体的には、２行目と２列目の位置を数値とみなし、
        ２行目＜２列目という条件を課せばよい
という枝仮ルールを実現している処理となります。

```python
  else:
    if row<BOUND1:    # 枝刈り
      bitmap=bitmap|2
      bitmap=bitmap^2
    while bitmap:
    """
    上から２行目のクイーンの位置が左から何番目にあるかと、
    右から２列目のクイーンの位置が上から何番目にあるかを、
    比較するだけで判定します。
    具体的には、２行目と２列目の位置を数値とみなし、
    ２行目＜２列目という条件を課せばよい
    結論： 以下の図では、１，２，４を枝刈りを入れる
      
      +-+-+-+-+-+  
      | | | |X|Q| 
      +-+-+-+-+-+  
      | |Q| |X| |  8（左から数えて１，２，４，８）
      +-+-+-+-+-+  
      | | | |X| |       
      +-+-+-+-+-+             
      | | | |Q| |  8（上から数えて１，２，４，８） 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
    """
```

たったこれだけの２行ですごいですね。
```python
      bitmap=bitmap|2
      bitmap=bitmap^2
```


### 角にＱがない時の処理
ここは少しわかりにくいですね。丁寧に説明文を入れましたので、じっくりと理解してみてください。
```python
    else                            # Qが角にない
      : '
      オリジナルがユニーク解であるためには先ず、
      前提：symmetryOpsは回転・鏡像変換により得られる状態の
      ユニーク値を比較し最小のものだけがユニーク解となるようにしている。
      Qができるだけ右に置かれている方がユニーク値は小さい。
      例えば1行目の2列目にQが置かれている方が3列目に置かれているより
      ユニーク値は小さくユニーク解に近い。
      1行目のクイーンの位置が同じなら2行目のクイーンの位置がより右の
      列におかれているものがユニーク値は小さくユニーク解に近い。

      下図の X への配置は禁止されます。
      Qの位置より右位置の８対象位置（X）にクイーンを置くことはできない。
      置いた場合回転・鏡像変換したユニーク値が最小にならなくなり、symmetryOps
      で負けるので枝刈りをする


      1行目のクイーンが3列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X| | | |Q|X|X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X| 
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |
      +-+-+-+-+-+-+-+-+
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X|X| | | | |X|X|
      +-+-+-+-+-+-+-+-+

      1行目のクイーンが4列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X|X| |Q|X|X|X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X|       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X|X|X| | |X|X|X|
      +-+-+-+-+-+-+-+-+

      プログラムではこの枝刈を上部サイド枝刈り、下部サイド枝刈り、最下段枝刈り
      の3か所で行っている
      それぞれ、1,2,3の数字で表すと以下の通り

      1行目のクイーンが3列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X| | | |Q|X|X| 
      +-+-+-+-+-+-+-+-+  
      |1| | | | | | |1| 
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |
      +-+-+-+-+-+-+-+-+
      |2| | | | | | |2|
      +-+-+-+-+-+-+-+-+
      |2|3| | | | |3|2|
      +-+-+-+-+-+-+-+-+
      1行目にXが残っているが当然Qの効き筋なので枝刈する必要はない
      ';
    if row<BOUND1:          # 上部サイド枝刈り
      bitmap=bitmap|SIDEMASK
      bitmap=bitmap^SIDEMASK
    else:
      if row==BOUND2:       # 下部サイド枝刈り
        if not down&SIDEMASK:
          return
        if down&SIDEMASK!=SIDEMASK:
          bitmap=bitmap&SIDEMASK
```

## symmetryOps()メソッド
ここもロジックを理解するところから初めて見ると良いと思います。
あまり細かいことを考えるよりも、大枠でどんなときにこのメソッドが呼ばれ、カウンターがいつインクリメントするのか、などを掴んだほうが良いと思います。

symmetryOps()では以下を実現しています。

  ２．クイーンが右上角以外にある場合、
  (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
  ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
  ジナルと同型になる。
  こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパター
  ンを加えて２個しかありません。
  ２．クイーンが右上角以外にある場合、
    (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナル
    とは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有り得
    る。こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同
    型になる場合は４個(左右反転×縦横回転)
  ２．クイーンが右上角以外にある場合、
    (3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)

  クイーンの利き筋を辿っていくと、オリジナルがユニーク解ではない可能性があり、
  それは下図の A,B,C の位置のどこかにクイーンがある場合に限られます。
  symmetryOpsは、以下の図のＡ，Ｂ，ＣにＱが置かれた場合にユニーク解かを判定します。
  原型と、90,180,270回転させたもののユニーク値を比較します。

```
     0 1 2 3 4 
    +-+-+-+-+-+  
    | | | | |Q|    4
    +-+-+-+-+-+  
    | | |Q| | |    2 
    +-+-+-+-+-+  
    |Q| | | | |    0  ----> 4 2 0 3 1 （ユニーク判定値）
    +-+-+-+-+-+             数が大きい方をユニークとみなす 
    | | | |Q| |    3
    +-+-+-+-+-+  
    | |Q| | | |    1 
    +-+-+-+-+-+  

     0 1 2 3 4     左右反転！
    +-+-+-+-+-+  
    |Q| | | | |    0
    +-+-+-+-+-+  
    | | |Q| | |    2 
    +-+-+-+-+-+  
    | | | | |Q|    4  ----> 0 2 4 1 3 
    +-+-+-+-+-+            数が小さいのでユニーク解とはしません 
    | |Q| | | |    1
    +-+-+-+-+-+  
    | | | |Q| |    3 
    +-+-+-+-+-+  
```

  Qができるだけ右に置かれている方がユニーク値は大きくなります。
  例えば1行目の2列目にQが置かれている方が、
  3列目に置かれているよりユニーク値は大きくユニーク解に近い。
  1行目のクイーンの位置が同じなら2行目のクイーンの位置がより右の列におかれてい
  るものがユニーク値は大きくユニーク解に近くなります。
  それ以外はユニーク解なのでCOUNT8にする

```
   +-+-+-+-+-+-+-+-+  
   |X|X| | | |Q|X|X| 
   +-+-+-+-+-+-+-+-+  
   |X| | | |x|x|x|X| 
   +-+-+-+-+-+-+-+-+  
   |C| | |x| |x| |x|       
   +-+-+-+-+-+-+-+-+             
   | | |x| | |x| | | 
   +-+-+-+-+-+-+-+-+ 
   | |x| | | |x| | |      
   +-+-+-+-+-+-+-+-+  
   |x| | | | |x| |A|
   +-+-+-+-+-+-+-+-+
   |X| | | | |x| |X|
   +-+-+-+-+-+-+-+-+
   |X|X|B| | |x|X|X|
   +-+-+-+-+-+-+-+-+
```

   Aの場合 右90度回転   board[BOUND2]==1
   Bの場合 右180度回転  board[size-1]==ENDBIT
   Cの場合 右270度回転  board[BOUND1]==TOPBIT


## 実行結果
実行結果は以下のとおりです。
```
0
 0 2 4 1 3
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

0
 1 4 2 0 3
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

TOTAL:10 COUNT2:1 COUNT4:0 COUNT8:1
```




"Ｎクイーン問題（４５）第七章 キャリーチェーン Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

[エイト・クイーンのソース置き場 BashもJavaもPythonも！](https://github.com/suzukiiichiro/N-Queens)


## キャリーチェーン
キャリーチェーンはＮ２７の解を発見したドレスデン大学の研究者が編み出したアルゴリズムです。

Jeffサマーズがミラーとビットマップの組み合わせでＮ２３を発見し、電気通信大学がサマーズのアルゴリズムを並列処理しＮ２４を発見、プロアクティブが対称解除法でＮ２５を発見し、Ｎ２７でキャリーチェーンによりドレスデン大学が世界一となりました。

Bash版の対称解除法の実行結果を見てみましょう。
[Ｎクイーン問題（１５）第三章　対象解除法 ロジック解説](https://suzukiiichiro.github.io/posts/2023-04-13-02-nqueens-suzuki/)
```
#  <> 06Bash_symmetry.sh 対象解除法
#  N:        Total       Unique        hh:mm:ss
#  4:            2            1         0:00:00
#  5:           10            2         0:00:00
#  6:            4            1         0:00:00
#  7:           40            6         0:00:00
#  8:           92           12         0:00:00
#  9:          352           46         0:00:00
# 10:          724           92         0:00:02
# 11:         2680          341         0:00:05
# 12:        14200         1787         0:00:26
# 13:        73712         9233         0:02:28
# 14:       365596        45752         0:14:18
# 15:      2279184       285053         1:23:34
```


Ｎ２５で、１時間２３分かかっています。
Bashだからこその遅さです。ＣプログラムではＮ１７までは１秒かかりません。
とはいえ、アルゴリズムやロジックを深く知るためには、プログラムのシンタックスに悩むドデカ級のプログラム言語よりも、身近なBash言語のほうが直感的でよいのです。
ＵＮＩＸを開発したＡＴ＆Ｔベル研究所では、開発者はBashでプロトタイプを作り、その後プログラマがＣに移植します。

新しい開発、革新的なロジックを研究することにBashは多くの現場で活躍してきました。ＣやJavaは、知恵を導入するまえに、構文（シンタックス）の複雑さに気を奪われ、書いた気になる、作った気になる言語と言われています。

では、Ｎ２７を叩き出したドレスデン大学のソースをBashに移植して、高速化、最適化したソースの実行結果を見てみます。

[Ｎクイーン問題（１９）第五章 キャリーチェーン](https://suzukiiichiro.github.io/posts/2023-05-23-01-n-queens-suzuki/)
```
#  <> 07Bash_carryChain.sh
#  N:        Total       Unique        hh:mm:ss
#  4:            2            1         0:00:00
#  5:           10            2         0:00:00
#  6:            4            1         0:00:00
#  7:           40            6         0:00:01
#  8:           92           12         0:00:02
#  9:          352           46         0:00:12
# 10:          724           92         0:00:44
# 11:         2680          341         0:02:39
# 12:        14200         1788         0:08:35
# 13:        73712         9237         0:27:05
# 14:       365596        45771         1:30:40
# 15:      2279184       285095         5:59:03
```

おそい。。。。
遅すぎますね。大丈夫なのでしょうか。

実際、とてつもなく遅いのですが、キャリーチェーンとは

１．対称解除とは比較にならないほど遅い
２．対称解除とは比較にならないほどメモリ消費量が小さい
３．対称解除と比べ、Ｎが小さいときに遅いが、Ｎが大きくなるに従って対称解除のスピードに追いつき、Ｎ１７で対称解除を追い抜き安定して実行を継続する。
４．一方で対称解除は、Ｎが小さいときは快調だが、Ｎが大きくなるに従って、board配列を中心にメモリ消費量が爆発的に肥大し、Ｎ１７以降、高い確率でバースト、システムは停止する。

ということで、キャリーチェーンは、遅いけど安定的に処理し続けるアルゴリズムなのです。

さらに、次の章で紹介する並列処理に極めて高い親和性があるアルゴリズムです。

## アルゴリズム
おおまかなアルゴリズムを説明します。
ソースはおおよそ下から積み上げるようにして書きますので、
最初の実行は一番下の「function NQ()」となります。

```bash
# 'ボード外側２列を除く内側のクイーン配置処理';
def solve(row,left,down,right):
# 'solve()を呼び出して再帰を開始する';
def process(size,sym):
# 'キャリーチェーン対称解除法';
def carryChainSymmetry(size,n,w,s,e):
# 'クイーンの効きをチェック';
def placement(size,dimx,dimy):
# 'チェーンのビルド';
def buildChain(size):
# 'チェーンの初期化';
def initChain(size):
# 'チェーンの構築';
def carryChain(size):
```

## ロジック解説
まず、NQ()を実行するとcarryChain()を呼び出します。
carrychain()は、チェーンの初期化を行うinitChain()と、チェーンのビルドを行う buildChain()を実行します。

チェーンの初期化を行う initChain()は以下の２行のクイーンが配置できるすべてをブルートフォースで導き出します。ここではクイーンの効きは考慮しません。
１行目の配置を pres_a配列に、２行目の配列をpres_b配列に保存します。

initChain()
```
+-+-+-+-+-+-+-+
|Q|Q|Q|Q|Q|Q|Q|
+-+-+-+-+-+-+-+
|Q|Q|Q|Q|Q|Q|Q|
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
```

次にbuildChain()は、上２行に配置します。
buildChain()では配置のたびに placement()を呼び出し、クイーンの効きに問題がないかをチェックします。
ざっくりいうと上１行目のクイーンはミラーのロジックにより、Ｎの半分しか配置しません。上２行目はＮすべてを配置候補とします。

buildChain()
```
+-+-+-+-+-+-+-+
| | | | | | |Q|  ←
+-+-+-+-+-+-+-+
| | | | |Q|x|x|  ←
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
| | | | | | | |
+-+-+-+-+-+-+-+
```

上２行に配置できたら、左２列を作成します。
```
 ↓↓
+-+-+-+-+-+-+-+
|x|x| | | | |Q| 
+-+-+-+-+-+-+-+
|x|x|x|x|Q|x|x| 
+-+-+-+-+-+-+-+
|Q|x|x|x|x|x|x|
+-+-+-+-+-+-+-+
|x|x|x|x|x| |x|
+-+-+-+-+-+-+-+
|x|x|x|x|x|x|x|
+-+-+-+-+-+-+-+
|x|Q|x|x|x|x|x|
+-+-+-+-+-+-+-+
|x|x|x|Q|x|x|x|
+-+-+-+-+-+-+-+
```

左２列が完成したら、下２行を作成します。
クイーンの配置の都度、placement()が呼び出され、クイーンの効きをチェックします。

```
+-+-+-+-+-+-+-+
|x|x|x|x|x|x|Q| 
+-+-+-+-+-+-+-+
|x|x| | |Q|x|x|
+-+-+-+-+-+-+-+
|Q|x| |x|x| |x|
+-+-+-+-+-+-+-+
|x|x|x|x|x| |x|
+-+-+-+-+-+-+-+
|x|x|x|x|x|x|x|
+-+-+-+-+-+-+-+
|x|Q|x|x|x|x|x| ←
+-+-+-+-+-+-+-+
|x|x|x|Q|x|x|x| ←
+-+-+-+-+-+-+-+
```

すでに配置されている場合はそれを許可し、配置したことにします。
下２行を作成したら、右２列を作成します。

```
+-+-+-+-+-+-+-+
|x|x|x|x|x|x|Q| 
+-+-+-+-+-+-+-+
|x|x| |x|Q|x|x|
+-+-+-+-+-+-+-+
|Q|x| |x|x|x|x|
+-+-+-+-+-+-+-+
|x|x|x|x|x|Q|x|
+-+-+-+-+-+-+-+
|x|x|x|x|x|x|x|
+-+-+-+-+-+-+-+
|x|Q|x|x|x|x|x|
+-+-+-+-+-+-+-+
|x|x|x|Q|x|x|x|
+-+-+-+-+-+-+-+
           ↑↑
```

配置が終わりました。
配置が終わったら、carryChainSymmetry()を呼び出して、対称解除法を実行します。


これまでのsymmetry.shでは１行目のクイーンが角にあるか、ないかで分岐し、クイーンの配置がすべて完了したら対称解除を行ってきました。ようするに処理の最終局面で対称解除を行ってきたわけです。

ですので、ボード情報をboard配列に入れて９０度回転を繰り返してきました。この処理はbit処理でなかった（僕がどうやってよいか分からなかった）ため、負荷も高くなってしまいました。

盤面のクイーンの配置すべてを格納したboard配列をまるっと９０度回転、さらに９０度回転、さらにさらに９０度回転と繰り返して、COUNT2,COUNT4,COUNT8のユニーク解を導き出していました。

キャリーチェーンは、盤面の外枠２行２列のみにクイーンを配置します。理由は「対称解除は２行２列に配置されていれば可能」だからです。

![](1.png)

まず、２行２列を配置し、対称解除を行い、COUNT2,COUNT4,COUNT8のいずれかである場合にかぎって、内側にクイーンの配置処理に入ります。

![](2.png)

すごいですね！ 新しいです。
最初に対称解除を行うことができるから、最初からbit処理可能です。そして最後までbit処理で完結できます。

これまでやってきた枝刈りのロジックは、ドレスデン大学のソースにはありませんでしたが、追記しておきました。期待大！ですね。

ですが、激しく遅いのです。残念です。

とはいえ世界一となったこのロジックはただものではありません。極めて優れたロジックで、パッと見だめでもじつはイケてるプログラムなのです。





## キャリーチェーン　プログラムソース
```python:07Python_carryChain.py
#!/usr/bin/env python3

# -*- coding: utf-8 -*-
import copy
"""
キャリーチェーン版 Ｎクイーン

詳細はこちら。
【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから
https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題

エイト・クイーンのプログラムアーカイブ
Bash、Lua、C、Java、Python、CUDAまで！
https://github.com/suzukiiichiro/N-Queens

# 実行 
$ python <filename.py>

# 実行結果
bash-3.2$ python 07Python_carryChain.py
size: 5 TOTAL: 10 UNIQUE: 2
bash-3.2$

"""
#
# グローバル変数
TOTAL=0
UNIQUE=0
pres_a=[0]*930
pres_b=[0]*930
COUNTER=[0]*3
B=[]
#
# ボード外側２列を除く内側のクイーン配置処理
def solve(row,left,down,right):
  total=0
  if not down+1:
    return 1
  while row&1:
    row>>=1
    left<<=1
    right>>=1
  row>>=1           # １行下に移動する
  bitmap=~(left|down|right)
  while bitmap!=0:
    bit=-bitmap&bitmap
    total+=solve(row,(left|bit)<<1,down|bit,(right|bit)>>1)
    bitmap^=bit
  return total
#
# キャリーチェーン　solve()を呼び出して再起を開始する
def process(size,sym):
  global B
  global COUNTER
  # sym 0:COUNT2 1:COUNT4 2:COUNT8
  COUNTER[sym]+=solve(
        B[0]>>2,
        B[1]>>4,
        (((B[2]>>2|~0<<size-4)+1)<<size-5)-1,
        B[3]>>4<<size-5
  )
#
# キャリーチェーン　対象解除
def carryChainSymmetry(size,n,w,s,e):
  global B
  # n,e,s=(N-2)*(N-1)-1-w の場合は最小値を確認する。
  ww=(size-2)*(size-1)-1-w
  w2=(size-2)*(size-1)-1
  # 対角線上の反転が小さいかどうか確認する
  if s==ww and n<(w2-e): return 
  # 垂直方向の中心に対する反転が小さいかを確認
  if e==ww and n>(w2-n): return
  # 斜め下方向への反転が小さいかをチェックする
  if n==ww and e>(w2-s): return
  # 【枝刈り】１行目が角の場合
  # １．回転対称チェックせずにCOUNT8にする
  if not B[4][0]:
    process(size,2) # COUNT8
    return
  # n,e,s==w の場合は最小値を確認する。
  # : '右回転で同じ場合は、
  # w=n=e=sでなければ値が小さいのでskip
  # w=n=e=sであれば90度回転で同じ可能性 ';
  if s==w:
    if n!=w or e!=w: return
    process(size,0) # COUNT2
    return
  # : 'e==wは180度回転して同じ
  # 180度回転して同じ時n>=sの時はsmaller?  ';
  if e==w and n>=s:
    if n>s: return
    process(size,1) # COUNT4
    return
  process(size,2)   # COUNT8
  return
#
# キャリーチェーン 効きのチェック dimxは行 dimyは列
def placement(size,dimx,dimy):
  global B
  if B[4][dimx]==dimy:
    return 1
  #
  #
  # 【枝刈り】Qが角にある場合の枝刈り
  #  ２．２列めにクイーンは置かない
  #  （１はcarryChainSymmetry()内にあります）
  #
  #  Qが角にある場合は、
  #  2行目のクイーンの位置 t_x[1]が BOUND1
  #  BOUND1行目までは2列目にクイーンを置けない
  # 
  #    +-+-+-+-+-+  
  #    | | | |X|Q| 
  #    +-+-+-+-+-+  
  #    | |Q| |X| | 
  #    +-+-+-+-+-+  
  #    | | | |X| |       
  #    +-+-+-+-+-+             
  #    | | | |Q| | 
  #    +-+-+-+-+-+ 
  #    | | | | | |      
  #    +-+-+-+-+-+  
  if B[4][0]:
    #
    # 【枝刈り】Qが角にない場合
    #
    #  +-+-+-+-+-+  
    #  |X|X|Q|X|X| 
    #  +-+-+-+-+-+  
    #  |X| | | |X| 
    #  +-+-+-+-+-+  
    #  | | | | | |
    #  +-+-+-+-+-+
    #  |X| | | |X|
    #  +-+-+-+-+-+
    #  |X|X| |X|X|
    #  +-+-+-+-+-+
    #
    #   １．上部サイド枝刈り
    #  if ((row<BOUND1));then        
    #    bitmap=$(( bitmap|SIDEMASK ));
    #    bitmap=$(( bitmap^=SIDEMASK ));
    #
    #  | | | | | |       
    #  +-+-+-+-+-+  
    #  BOUND1はt_x[0]
    #
    #  ２．下部サイド枝刈り
    #  if ((row==BOUND2));then     
    #    if (( !(down&SIDEMASK) ));then
    #      return ;
    #    fi
    #    if (( (down&SIDEMASK)!=SIDEMASK ));then
    #      bitmap=$(( bitmap&SIDEMASK ));
    #    fi
    #  fi
    #
    #  ２．最下段枝刈り
    #  LSATMASKの意味は最終行でBOUND1以下または
    #  BOUND2以上にクイーンは置けないということ
    #  BOUND2はsize-t_x[0]
    #  if(row==sizeE){
    #    //if(!bitmap){
    #    if(bitmap){
    #      if((bitmap&LASTMASK)==0){
    if B[4][0]!=-1:
      if(
        (dimx<B[4][0] or dimx>=size-B[4][0]) and 
        (dimy==0 or dimy==size-1) 
      ):
        return 0
      if(
        (dimx==size-1) and 
        (dimy<=B[4][0] or dimy>=size-B[4][0])
      ):
        return 0
  else:
    if B[4][1]!=-1:
      # bitmap=$(( bitmap|2 )); # 枝刈り
      # bitmap=$(( bitmap^2 )); # 枝刈り
      #((bitmap&=~2)); # 上２行を一行にまとめるとこうなります
      # ちなみに上と下は同じ趣旨
      # if (( (t_x[1]>=dimx)&&(dimy==1) ));then
      #   return 0;
      # fi
      if B[4][1]>=dimx and dimy==1:
        return 0
  if( (B[0] & 1<<dimx) or 
      (B[1] & 1<<(size-1-dimx+dimy)) or
      (B[2] & 1<<dimy) or
      (B[3] & 1<<(dimx+dimy)) 
  ): 
    return 0
  B[0]|=1<<dimx
  B[1]|=1<<(size-1-dimx+dimy)
  B[2]|=1<<dimy
  B[3]|=1<<(dimx+dimy)
  B[4][dimx]=dimy
  return 1
#
# チェーンのビルド
def buildChain(size):
  global B
  global pres_a
  global pres_b
  B=[0,0,0,0,[-1]*size] # Bの初期化
  wB=sB=eB=nB=[]
  wB=copy.deepcopy(B)
  for w in range( (size//2)*(size-3) +1):
    B=copy.deepcopy(wB)
    B=[0,0,0,0,[-1]*size] # Bの初期化
    # １．０行目と１行目にクイーンを配置
    if placement(size,0,pres_a[w])==0:
      continue
    if placement(size,1,pres_b[w])==0:
      continue
    # ２．９０度回転
    nB=copy.deepcopy(B)
    mirror=(size-2)*(size-1)-w
    for n in range(w,mirror,1):
      B=copy.deepcopy(nB)
      if placement(size,pres_a[n],size-1)==0:
        continue
      if placement(size,pres_b[n],size-2)==0:
        continue
      # ３．９０度回転
      eB=copy.deepcopy(B)
      for e in range(w,mirror,1):
        B=copy.deepcopy(eB)
        if placement(size,size-1,size-1-pres_a[e])==0:
          continue
        if placement(size,size-2,size-1-pres_b[e])==0:
          continue
        # ４．９０度回転
        sB=copy.deepcopy(B)
        for s in range(w,mirror,1):
          B=copy.deepcopy(sB)
          if placement(size,size-1-pres_a[s],0)==0:
            continue
          if placement(size,size-1-pres_b[s],1)==0:
            continue
          # 対象解除法
          carryChainSymmetry(size,n,w,s,e)
#
# チェーンの初期化
def initChain(size):
  global pres_a
  global pres_b
  idx=0
  for a in range(size):
    for b in range(size):
      if (a>=b and (a-b)<=1) or (b>a and (b-a<=1)):
        continue
      pres_a[idx]=a
      pres_b[idx]=b
      idx+=1
#
# キャリーチェーン
def carryChain(size):
  global B
  global TOTAL
  global UNIQUE
  global COUNTER
  TOTAL=UNIQUE=0
  COUNTER[0]=COUNTER[1]=COUNTER[2]=0
  # Bの初期化  [0, 0, 0, 0, [0, 0, 0, 0, 0]]
  B=[0]*5             # row/left/down/right/X
  B[4]=[-1]*size       # X を0でsize分を初期化
  initChain(size)     # チェーンの初期化
  buildChain(size)    # チェーンのビルド
  # 集計
  UNIQUE=COUNTER[0]+COUNTER[1]+COUNTER[2]
  TOTAL=COUNTER[0]*2 + COUNTER[1]*4 + COUNTER[2]*8
#
# 実行
size=5
carryChain(size)    # ７．キャリーチェーン
print("size:",size,"TOTAL:",TOTAL,"UNIQUE:",UNIQUE)
#
```

次回は、Ｎを順番に処理していく「ステップＮ」をやります。




"Ｎクイーン問題（４６）第七章 ステップＮの実装 Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

[エイト・クイーンのソース置き場 BashもJavaもPythonも！](https://github.com/suzukiiichiro/N-Queens)


## ステップＮの実装
なんでしたっけ？それ。
あれです。以下に示します。

```
bash-3.2$ python 08Python_stepN.py
キャリーチェーン
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.001
 6:            4            1         0:00:00.004
 7:           40            6         0:00:00.023
 8:           92           12         0:00:00.112
 9:          352           46         0:00:00.514
10:          724           92         0:00:02.007
11:         2680          341         0:00:06.930
12:        14200         1788         0:00:21.436
bash-3.2$
```

シリーズのバックナンバーによく出てきました。




次回からは、ここまでやってきたPythonのコードを最適化、最速化していきます。
お楽しみに！





"Ｎクイーン問題（４７）第七章 クラス Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

[エイト・クイーンのソース置き場 BashもJavaもPythonも！](https://github.com/suzukiiichiro/N-Queens)


## クラス
これまで配列（リスト）を使って表現してきたわけですが、並列処理を視野に入れて、オブジェクティブ（オブジェクト指向）に修正していきたいと思います。

とはいえ、実際はクラスを導入するとＮクイーン問題における処理速度は低下します。しないという人がいたらその人はただの頑固者です。

初心者にとって見れば「クラス」「継承」を使って、マルチプロセスを実装したほうがわかりやすいのです。

クラスを理解できて
↓
シングルスレッドを実装できて
↓
マルチスレッドを実装できて（継承とロックが理解できた）
↓
マルチプロセスが実装できて（並列処理の同期が理解できた）

こうした順番を経て最終的に、

クラスを一つでも廃止、
グローバル変数を極力廃止してローカル変数、パラメータ渡しに変更
配列・オブジェクトの扱い方を工夫
アルゴリズムの見直す

というステージに上がるわけです。
いずれにしても、今のところは「クラス」で行きましょう。

## クラスとはこういうもの
クラスはこういうものです。
クラスがどういうものか？
という人は、別のサイトに行って調べたほうが良いです。

```python
class Board:
  def __init__(self,size):
    self.size=size
    self.row=0
    self.left=0
    self.down=0
    self.right=0
    self.X=[-1 for i in range(size)]
```

## クラスを作成する

Javaで言うところのインスタンスを作成するには以下のようにします。
以下は、BoardクラスをBという名前でインスタンスを作成しました。
```python
B=Board(self.size)
```

## クラスの変数にアクセスする

こんな感じです。
```python
print( self.B.row )
```


## 実行結果
```
クラスの導入
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.002
 6:            4            1         0:00:00.010
 7:           40            6         0:00:00.044
 8:           92           12         0:00:00.204
 9:          352           46         0:00:00.885
10:          724           92         0:00:03.450
11:         2680          341         0:00:11.908
12:        14200         1788         0:00:36.707
```




"Ｎクイーン問題（４８）第七章 シングルスレッド Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

[エイト・クイーンのソース置き場 BashもJavaもPythonも！](https://github.com/suzukiiichiro/N-Queens)


## シングルスレッド
マルチスレッドを作成する前にシングルスレッドを作ってみます。
「今までのも考えようによってはシングルスレッドだ」
というばかちんがいそうですが、全然違います。
シングルスレッドの構造になって初めてマルチスレッドに展開できるわけで、通常の処理とシングルスレッドは異なります。


## シングルスレッドの実装

前回やっておけばよかったのですが、`pres_a`と`pres_b`を母体クラスのグローバルへ移行します。
というのも、チェーンを初期化してビルドするまでしか使わないので、いつまでも`Board`クラスにあっても意味ないですから。

## シングルスレッド移行への段取り

１．ソース冒頭に以下を追加しておきます。
```python
import logging
import threading
from threading import Thread
```


２．`nQueens`クラスの引数にThreadを追加
これで`nQueens`クラスはThreadクラスを「継承した」ということになります。
```python
#
# nQueens メインスレッドクラス
class nQueens(Thread): # pylint:disable=RO902
  #
```


３．Threadクラスを継承した`nQueens`クラスに `run()`を追加
`Thread`にはもともと`run()`があります。
`nQueens`クラスに`run()`を追加するというのは、元々ある`run()`をオーバーライド（上書き）するという意味です。
JavaやPythonでは「Threadクラスのrun()メソッドをオーバーライドする」と言います。
```python
  #
  # シングルスレッド
  def run(self):
    if self.child is None:
      self.buildChain()  # チェーンのビルド
  #
```

４．`main()`にスレッドを作成
Threadを継承した`nQueens`クラスを`nq`でインスタンスします。
その後、`nq.carryChain()`で処理を開始し、`nq.start()`で `run()`の処理を開始します。
`run()`は一度しか実行されません。ぐるぐる回転するわけではありません。
最後に、それぞれの処理がすべて終わるまで待機してくれる`nq.join()`を実行します。
```python
メインクラスにて親スレッドを作成して実行
    start_time = datetime.now()
    nq=nQueens(size)
    nq.carryChain()
    nq.start()
    nq.join()
    time_elapsed = datetime.now() - start_time
```


## 実行結果
```
キャリーチェーン シングルスレッド
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.002
 6:            4            1         0:00:00.010
 7:           40            6         0:00:00.044
 8:           92           12         0:00:00.204
 9:          352           46         0:00:00.885
10:          724           92         0:00:03.527
11:         2680          341         0:00:12.188
12:        14200         1788         0:00:37.435
```




"Ｎクイーン問題（４９）第七章 マルチスレッド Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

[エイト・クイーンのソース置き場 BashもJavaもPythonも！](https://github.com/suzukiiichiro/N-Queens)


## マルチスレッド
やってきましたマルチスレッド。
なんか速くなりそうですね。
でもほぼシングルスレッドと速度は変わりません。

並列処理された、バラバラに動いてる。
ということに驚きがある人はそれで良いです。

Pythonのマルチスレッドは、あくまでマルチプロセスへの橋渡しに過ぎません。速度はほとんど変わりません。
Ｎクイーンでは、むしろ遅くなりました（笑）

## シングルスレッドとマルチスレッドの切り替えトグルの作成
マルチスレッドを実装する場合、最初のうちはまったく動きません。
動かないのです。
動いても、そう簡単に解の数があいません。
下手をすると、Ｎが１１まではあっているけど、Ｎ１２から微妙に異なるということもあります。

必ず何処かに間違いがあって、その間違いはＮが大きくなるに連れて顕著になるということなのですが、そういったバグを修正するにも、「ちゃんと正しく動く」という部分を軸に検証していくしかありません。

ということで、以下のようなフラグを作成します。
以下の場合だと、THREADはTrueなのでマルチスレッドモードになります。
まずは、THREAD=Falseで動くようにするのが、第一歩です。
```python
#
# スレッドフラグ True:する False:しない
THREAD=True
# THREAD=False
#
```


## nQueens()クラスのコンストラクタ`__init__`
以下のように、TREADフラグが渡されて、THREADがTrueのときと、Falseのときの条件分岐を追加します。
まずは、Falseのときの条件分岐が実行できるようになるのが目標です。

```python
  #
  # 初期化
  def __init__(self,size,w,count,THREAD): # pylint:disable=R0913
    super(nQueens,self).__init__()
    self.size=size
    # self.COUNTER=[0]*3
    self.count=count
    self.pres_a=[0]*930
    self.pres_b=[0]*930
    self.B=Board(size)
    self.w=w      # マルチスレッド版ビルドチェーン外側の`for` の w
    self.child=None
    self.THREAD=THREAD      # スレッドフラグ 
    # マルチスレッド
    #for w in range( (self.size//2)*(self.size-3) +1):
    self.range=(self.size//2)*(self.size-3) +1
    if THREAD:  # THREAD フラグがTrueのときはマルチスレッド
      if w<self.range: 
        self.child=nQueens(size,w+1,count,THREAD)
        self.carryChain()
        self.child.start()
        # self.child.join()   # run()の末尾へ移動
    else:       # THREAD フラグがFalseのときはシングルスレッド
      self.child=None
```

## `run()`関数
以下のように`run()`関数に、THREADがTrueのとき、Falseのときの分岐を追加します。
コンストラクタで条件を追加したら、`start()`で実行される`run()`の以下の条件分岐を追記してください。
```python
  #
  # スレッド
  def run(self):
    if self.child is None:
    # シングルスレッド
      self.buildChain()  # チェーンのビルド
    else:
    # マルチスレッド
      self.buildChain_multiThread(self.w)
      self.child.join()
```

## カウンタークラス`Count`を作成
やっぱり`nQueens`クラスからカウンターは外したほうが良いのです。
`Board`クラスにカウンターを置いても、ビルドチェーンで、初期化や`copy.deepcopy()`されて、せっかくカウントしてもカウンターが０になってしまったりと心配です。
今回は独立クラスに昇格させます。
```python
#
# カウンタークラス　ロック付き
class Count:
  def __init__(self,lock):
    self.COUNTER=[0]*3
    self.lock=lock
  #
  # ユニーク数の集計
  def getUnique(self):
    return self.COUNTER[0]+self.COUNTER[1]+self.COUNTER[2]
  #
  # 合計解の集計
  def getTotal(self):
    return self.COUNTER[0]*2+self.COUNTER[1]*4+self.COUNTER[2]*8
  #
  # カウンター セッター
  def setCount(self,sym,count):
    with self.lock:
      self.COUNTER[sym]+=count
      # print(str("sym:" + str(sym) + "count:" +str(count)))
```

## ロック
カウンターは特にそうなのですが、ロック（排他処理）しないと、カウントしたい複数の処理がほぼ同時にカウンターにアクセスした場合、最悪は、両方とも衝突して正常な処理ができない場合も多いのです。
ということで、読み込み、書き込みをし始めたらロックをして他の人がさわれないようにしてまっていてもらい、書き込みが終わって「いいよ」という合図があって初めてロックを解除して次の人が読み込んで書き込むという一連の安全機構が「ロック」なのです。

main()クラスからロックの下準備が始まっています。
```python
    lock=threading.Lock()
    count=Count(lock)
    nq=nQueens(size,w,count,THREAD)
    nq.carryChain()
    nq.start()
    nq.join()
    time_elapsed = datetime.now() - start_time
```

該当のクラス`class Count`のコンストラクタに`lock`を渡していますね。
渡された`class Count`を見てみましょう。

```python
#
# カウンタークラス　ロック付き
class Count:
  def __init__(self,lock):
    self.COUNTER=[0]*3
    self.lock=lock
  #
```

これで、`class Count`はロック機構が使えます。
どこで使うかというと、書き込みのメソッドになります。
具体的には、以下のメソッドです。
```python
  #
  # カウンター セッター
  def setCount(self,sym,count):
    with self.lock:
      self.COUNTER[sym]+=count
      # print(str("sym:" + str(sym) + "count:" +str(count)))
```

with self.lock: 
という部分が、「この関数はlock機構がついてますよ」という意味となります。



## 実行結果
```
bash-3.2$ python 12Python_multiThread.py
キャリーチェーン シングルスレッド
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.002
 6:            4            1         0:00:00.010
 7:           40            6         0:00:00.046
 8:           92           12         0:00:00.205
 9:          352           46         0:00:00.910
10:          724           92         0:00:03.542
11:         2680          341         0:00:12.184
12:        14200         1788         0:00:36.986


bash-3.2$ python 12Python_multiThread.py
キャリーチェーン マルチスレッド
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.003
 6:            4            1         0:00:00.013
 7:           40            6         0:00:00.049
 8:           92           12         0:00:00.215
 9:          352           46         0:00:00.934
10:          724           92         0:00:03.690
11:         2680          341         0:00:12.708
12:        14200         1788         0:00:40.294
```



"Ｎクイーン問題（５０）第七章 マルチプロセス Python編"
[【参考リンク】Ｎクイーン問題 過去記事一覧はこちらから](https://suzukiiichiro.github.io/search/?keyword=Ｎクイーン問題)

[エイト・クイーンのソース置き場 BashもJavaもPythonも！](https://github.com/suzukiiichiro/N-Queens)


## マルチプロセス
まずはBashの並列処理の実行結果を見てください。

```
 ## bash版
 <> 08Bash_carryChain_parallel.sh 並列処理
 N:        Total       Unique        hh:mm:ss
 4:            0            0         0:00:00
 5:            8            1         0:00:00
 6:            4            1         0:00:00
 7:           40            6         0:00:00
 8:           92           12         0:00:01
 9:          352           46         0:00:03
10:          724           92         0:00:15
11:         2680          341         0:00:52
12:        14200         1788         0:02:49
13:        73712         9237         0:09:18
14:       365596        45771         0:28:48
15:      2279184       285095         1:49:12 １時間４９分１２秒
```

遅いですね。
でも、ロジックは十分に理解できたと思います。

```
## C pthread版
bash-3.2$ gcc 17GCC_carryChain.c -o 17GCC && ./17GCC
７．キャリーチェーン
 N:        Total       Unique        dd:hh:mm:ss.ms
 4:            2            1        00:00:00:00.00
 5:           10            2        00:00:00:00.00
 6:            4            1        00:00:00:00.00
 7:           40            6        00:00:00:00.00
 8:           92           12        00:00:00:00.00
 9:          352           46        00:00:00:00.00
10:          724           92        00:00:00:00.00
11:         2680          341        00:00:00:00.00
12:        14200         1788        00:00:00:00.01
13:        73712         9237        00:00:00:00.03
14:       365596        45771        00:00:00:00.11
15:      2279184       285095        00:00:00:00.41
16:     14772512      1847425        00:00:00:02.29
17:     95815104     11979381        00:00:00:18.08
18:    666090624     83274576        00:00:03:40.04
19:   4968057848    621051686        00:00:27:37.22
20:  39029188884   4878995797        00:03:39:23.79 ３時間３９分２３秒
bash-3.2$
```
速い。。。やっぱりＣは速いのです。もう言うことなしです。
で、Pythonのマルチプロセスはというと、

```
bash-3.2$ python 13Python_multiProcess.py
キャリーチェーン マルチプロセス
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.061
 6:            4            1         0:00:00.126
 7:           40            6         0:00:00.135
 8:           92           12         0:00:00.327
 9:          352           46         0:00:00.766
10:          724           92         0:00:02.327
11:         2680          341         0:00:09.042
12:        14200         1788         0:00:19.871
13:        73712         9237         0:00:53.388
14:       365596        45771         0:02:19.974
15:      2279184       285095         0:05:51.522
16:     14772512      1847425         0:17:01.656
17:     95815104     11979381         1:07:04.713
```

ま、１時間かけてBashでＮ１５まで処理できたところが、PythonだとＮ１７まで処理できました。

BashやPythonといったインタープリタの限界なのでしょうね。


## 解説とか
まずは以下を追加します。
```python
from multiprocessing import Pool as ThreadPool
```

マルチプロセスは`pool`が肝です。
`pool`で検索したその箇所に違いがあります。
ここでもシングルプロセス、マルチプロセスの切り替えフラグを作ります。
といっても、実際にフラグを作ったわけではなくて、以下のようにしました。

```python
  #
  # マルチプロセス
  def execProcess(self):
    #pool=ThreadPool(self.size)
    pool=ThreadPool((self.size//2)*(self.size-3) +1)
    #
    # シングルプロセスで実行
    #gttotal=list(pool.map(self.carryChain_single,range(1)))
    #
    # マルチプロセスで実行
    gttotal=list(pool.map(self.carryChain_multi,range( (self.size//2)*(self.size-3) +1)))

```


また、シングルプロセスとマルチプロセス時のメソッドの違いは、以下のとおりです。
```python
  #
  # シングルプロセス
  def carryChain_single(self,w):
    self.initChain()     # チェーンの初期化
    self.buildChain_singleThread(w)
    return self.getTotal(),self.getUnique()
  #
  # マルチプロセス
  def carryChain_multi(self,w):
    self.initChain()     # チェーンの初期化
    self.buildChain_multiThread(w)
    return self.getTotal(),self.getUnique()
```

以下の２つの関数は、`for`行を一行コメントアウトしてあるかいないかだけの違いです。

シングルプロセス版のビルドチェーン
```python
  #
  # シングルプロセス版 チェーンのビルド
  def buildChain_singleThread(self,w):
    wB=copy.deepcopy(self.B)
    for w in range( (self.size//2)*(self.size-3) +1):
      self.B=copy.deepcopy(wB)
      # １．０行目と１行目にクイーンを配置
```

マルチプロセス版のビルドチェーン
`for`をコメントアウトした場合は、その下の行を関数末尾まで左インデントするのをお忘れなく。
```python
  #
  # マルチプロセス版 チェーンのビルド
  def buildChain_multiThread(self,w):
    wB=copy.deepcopy(self.B)
    # for w in range( (self.size//2)*(self.size-3) +1):
    self.B=copy.deepcopy(wB)
    # １．０行目と１行目にクイーンを配置
```


で、どうやってシングルプロセスとマルチプロセスで実行を切り分けているかというと、シングルプロセスの場合は、以下のソースで、

```python
    gttotal=list(pool.map(self.carryChain_single,range(1)))
```

range(1) 
これで、プロセスは一つだけ起動します。


```python

  #
  # マルチプロセス
  def execProcess(self):
    #pool=ThreadPool(self.size)
    pool=ThreadPool((self.size//2)*(self.size-3) +1)
    #
    # シングルプロセスで実行
    #gttotal=list(pool.map(self.carryChain_single,range(1)))
    #
    # マルチプロセスで実行
    gttotal=list(pool.map(self.carryChain_multi,range( (self.size//2)*(self.size-3) +1)))

```

逆にマルチプロセスで実行したい場合は、
```python
    gttotal=list(pool.map(self.carryChain_multi,range( (self.size//2)*(self.size-3) +1)))
```

以下の行で、適宜プロセスがどどっと起動します。
```python
range( (self.size//2)*(self.size-3) +1)
```


## 集計
集計も肝のひとつです。

```python
  #
  # マルチプロセス
  def execProcess(self):
    #pool=ThreadPool(self.size)
    pool=ThreadPool((self.size//2)*(self.size-3) +1)
    #
    # シングルプロセスで実行
    #gttotal=list(pool.map(self.carryChain_single,range(1)))
    #
    # マルチプロセスで実行
    gttotal=list(pool.map(self.carryChain_multi,range( (self.size//2)*(self.size-3) +1)))
    #
    #
    # 集計処理
    total = 0 # ローカル変数
    unique = 0
    for _t, _u in gttotal:
      total+=_t
      unique+=_u
    pool.close()
    pool.join()
    return total,unique
```

実行結果を`map()`に入れて、それを`list`に入れて、`gttotal`に格納しています。その`gttotal`を `for`で繰り返し、`total`と`unique`にそれぞれ代入し（できるんです）`pool.close()`、`pool.join()`して最後に、`total`と`unique`をそれぞれ`return`します（できるんです）。

このソースは本当にトリッキーです。
その分、マルチスレッドではなかった速度で動きます。
スキルの向上にも手応えがあったと思います。



## 実行結果
```
bash-3.2$ python 13Python_multiProcess.py
キャリーチェーン マルチプロセス
 N:        Total       Unique        hh:mm:ss.ms
 5:           10            2         0:00:00.061
 6:            4            1         0:00:00.126
 7:           40            6         0:00:00.135
 8:           92           12         0:00:00.327
 9:          352           46         0:00:00.766
10:          724           92         0:00:02.327
11:         2680          341         0:00:09.042
12:        14200         1788         0:00:19.871
13:        73712         9237         0:00:53.388
14:       365596        45771         0:02:19.974
15:      2279184       285095         0:05:51.522
16:     14772512      1847425         0:17:01.656
17:     95815104     11979381         1:07:04.713
```


さ、これで退路が絶たれたわけです。
もうGPU/CUDAしかやりようがなくなりました。
次回からはGPU/CUDAをやっていきましょう。


