#!/usr/bin/bash

: '
エイト・クイーンの解説をしています。ご興味のある方はどうぞ。

Ｎクイーン問題（１８）第四章　偉人のソースを読む「エイト・クイーンノスタルジー」
https://suzukiiichiro.github.io/posts/2023-04-18-01-n-queens-suzuki/
Ｎクイーン問題（１７）第四章　偉人のソースを読む「Ｎ２４を発見 Ｊｅｆｆ Ｓｏｍｅｒｓ」
https://suzukiiichiro.github.io/posts/2023-04-21-01-n-queens-suzuki/
Ｎクイーン問題（１６）第三章　対象解除法 ソース解説
https://suzukiiichiro.github.io/posts/2023-04-18-01-n-queens-suzuki/
Ｎクイーン問題（１５）第三章　対象解除法 ロジック解説
https://suzukiiichiro.github.io/posts/2023-04-13-02-nqueens-suzuki/
Ｎクイーン問題（１４）第三章　ミラー
https://suzukiiichiro.github.io/posts/2023-04-13-01-nqueens-suzuki/
Ｎクイーン問題（１３）第三章　ビットマップ
https://suzukiiichiro.github.io/posts/2023-04-05-01-nqueens-suzuki/
Ｎクイーン問題（１２）第二章　まとめ
https://suzukiiichiro.github.io/posts/2023-03-17-02-n-queens-suzuki/
Ｎクイーン問題（１１）第二章　配置フラグの再帰・非再帰
https://suzukiiichiro.github.io/posts/2023-03-17-01-n-queens-suzuki/
Ｎクイーン問題（１０）第二章　バックトラックの再帰・非再帰
https://suzukiiichiro.github.io/posts/2023-03-16-01-n-queens-suzuki/
Ｎクイーン問題（９）第二章　ブルートフォースの再帰・非再帰
https://suzukiiichiro.github.io/posts/2023-03-14-01-n-queens-suzuki/
Ｎクイーン問題（８）第一章　まとめ
https://suzukiiichiro.github.io/posts/2023-03-09-01-n-queens-suzuki/
Ｎクイーン問題（７）第一章　ブルートフォース再び
https://suzukiiichiro.github.io/posts/2023-03-08-01-n-queens-suzuki/
Ｎクイーン問題（６）第一章　配置フラグ
https://suzukiiichiro.github.io/posts/2023-03-07-01-n-queens-suzuki/
Ｎクイーン問題（５）第一章　進捗表示テーブルの作成
https://suzukiiichiro.github.io/posts/2023-03-06-01-n-queens-suzuki/
Ｎクイーン問題（４）第一章　バックトラック
https://suzukiiichiro.github.io/posts/2023-02-21-01-n-queens-suzuki/
Ｎクイーン問題（３）第一章　バックトラック準備編
https://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/
Ｎクイーン問題（２）第一章　ブルートフォース
https://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/
Ｎクイーン問題（１）第一章　エイトクイーンについて
https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/

エイト・クイーンのソース置き場 BashもJavaもPythonも！
https://github.com/suzukiiichiro/N-Queens
';


: '
## 対象解除法について
まず、Ｎが小さな盤面で考えていきます。
以下、順に見て理解を深めてもらえればと思います。


##対象解除法について（Ｎ２版）
ひとつの解には、盤面を90度・180度・270度回転、及びそれらの鏡像の合計8個の対称解が存在します。

```
  原型   90度  180度   270度
  １２   ４１   ３４   ２３
  ４３   ３２   ２１   １４
  
      上の行を左右反転                     
  ２１   １４   ４３   ３２
  ３４   ２３   １２   ４１
```

上図左上がユニーク解です。
```
  原型（ユニーク解）
  １２ 
  ４３ 
```

１行目はユニーク解を90度、180度、270度回転したものです。
```
  原型   90度  180度   270度
  １２   ４１   ３４   ２３
  ４３   ３２   ２１   １４
```

2行目は1行目のそれぞれを左右反転したものです。
```
      上の行を左右反転                     
  ２１   １４   ４３   ３２
  ３４   ２３   １２   ４１
```

2行目はユニーク解を左右反転、対角反転、上下反転、逆対角反転したものとも解釈できます。
ただし、回転・線対称な解もあるので注意が必要です。

対称的な解を除去し、ユニーク解のみを求める方法はいくつかあります。
ここでは、一つの解には８つのパターンが存在することを覚えておいてください。


## 対象解を導き出す２つの方法
対象解を導き出す方法として、
１．解が見つかるたびに回転・対象をチェック
２．解のすべてを保存して、保存された解の回転・対象をチェック


最小解選択法 
解がひとつみつかるとすべての対称解を生成、 状態を数値とみなして最も小さいもののみを解とする方法。
最も最適と言われています。

最小選択法よりも劣る方法
解全てを保存しておき、新しい解が発見されるたびに対称形が無いかどうかを調べる方法。
保存領域を必要とするし、比較時に対称形を生成する必要があります。


## 対象解除法（Ｎ５版）
全探索によって得られたある１つの解が、回転・反転などによる本質的に変わることのない変換によって他の解と同型となるものが存在する場合、それを別の解とはしないとする解の数え方で得られる解を「ユニーク解」といいます。

ユニーク解とは、全解の中から回転・反転などによる変換によって同型になるものどうしをグループ化することを意味しています。

```
グループ１:
+-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | |Q| | | |
+-+-+-+-+-+  +-+-+-+-+-+
|Q| | | | |  | | | | |Q|
+-+-+-+-+-+  +-+-+-+-+-+
| | |Q| | |  | | |Q| | |
+-+-+-+-+-+  +-+-+-+-+-+
| | | | |Q|  |Q| | | | |
+-+-+-+-+-+  +-+-+-+-+-+
| |Q| | | |  | | | |Q| |
+-+-+-+-+-+  +-+-+-+-+-+

グループ２:
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| | | | |Q|  |Q| | | | |  | | |Q| | |  | | |Q| | |  | | | |Q| |  | |Q| | | |  |Q| | | | |  | | | | |Q|  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| | |Q| | |  | | |Q| | |  |Q| | | | |  | | | | |Q|  | |Q| | | |  | | | |Q| |  | | | |Q| |  | |Q| | | |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
|Q| | | | |  | | | | |Q|  | | | |Q| |  | |Q| | | |  | | | | |Q|  |Q| | | | |  | |Q| | | |  | | | |Q| |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| | | |Q| |  | |Q| | | |  | |Q| | | |  | | | |Q| |  | | |Q| | |  | | |Q| | |  | | | | |Q|  |Q| | | | |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
| |Q| | | |  | | | |Q| |  | | | | |Q|  |Q| | | | |  |Q| | | | |  | | | | |Q|  | | |Q| | |  | | |Q| | |  
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  
```

ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、この解はユニーク解ではないという定まった判定方法はありません。
ユニーク解であるかどうかの判断はユニーク解の個数を数える目的の為だけにあります。
どのような定義をしたとしてもユニーク解の個数それ自体は変わりません。

Ｎクイーン問題は、正方形のボードで形成されるので、回転・反転による変換パターンはぜんぶで８通りあります。

だからといって「全解数＝ユニーク解数×８」と単純にはいきません。
ひとつのグループの要素数が必ず８個あるとは限らないのです。

Ｎ＝５の例では２つのグループがあり、要素数が２個のグループ、要素数が８個のグループがあります。
結論から言うと、Ｎ＝５の全解は１０個で、ユニーク解は２個です。


## ユニーク解を判定するための定義
各行のクイーンが左から何番目にあるかを調べて、最上段の行(row)から下の行(row)へ順番に列挙します。
そしてそれをＮ桁の数値として見た場合に「最大値」となるものをユニーク解とします。
このＮ桁の数を以後は「ユニーク判定値」と呼ぶことにします。
```
 0 1 2 3 4 
+-+-+-+-+-+  
| | | | |Q|    4
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
|Q| | | | |    0  ----> 4 2 0 3 1 （ユニーク判定値）
+-+-+-+-+-+             数が大きい方をユニークとみなす 
| | | |Q| |    3
+-+-+-+-+-+  
| |Q| | | |    1 
+-+-+-+-+-+  

 0 1 2 3 4     左右反転！
+-+-+-+-+-+  
|Q| | | | |    0
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
| | | | |Q|    4  ----> 0 2 4 1 3 
+-+-+-+-+-+            数が小さいのでユニーク解とはしません 
| |Q| | | |    1
+-+-+-+-+-+  
| | | |Q| |    3 
+-+-+-+-+-+  
```

探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定するには、「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるかを調べる」ことになります。

Ｎ２の場合の８通りの変換
```
  原型   90度  180度   270度
  １２   ４１   ３４   ２３
  ４３   ３２   ２１   １４
  
      上の行を左右反転                     
  ２１   １４   ４３   ３２
  ３４   ２３   １２   ４１
```

結論から先にいえば、ユニーク解とは成り得ないことが明確なパターンを探索中に切り捨てる「枝刈り」を組み込むことにより、３通りの変換を試みるだけでユニーク解の判定が可能になります。


## 枝刈り
先ず最上段の行(row)のクイーンの位置に着目します。
その位置が左半分の領域にあればユニーク解には成り得ません。
何故なら左右反転によって得られるパターンのユニーク判定値の方が確実に小さくなるからです。
```
 0 1 2 3 4     
+-+-+-+-+-+  
|Q| | | | |    0
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
| | | | |Q|    4  ----> 0 2 4 1 3 
+-+-+-+-+-+            数が小さいのでユニークとはしません
| |Q| | | |    1
+-+-+-+-+-+  
| | | |Q| |    3 
+-+-+-+-+-+  

 0 1 2 3 4     左右反転！
+-+-+-+-+-+  
| | | | |Q|    4
+-+-+-+-+-+  
| | |Q| | |    2 
+-+-+-+-+-+  
|Q| | | | |    0  ----> 4 2 0 3 1 （ユニーク判定値）
+-+-+-+-+-+             数が大きい方をユニークとみなす 
| | | |Q| |    3
+-+-+-+-+-+  
| |Q| | | |    1 
+-+-+-+-+-+  
```


Ｎが奇数の場合に中央にあった場合はどうでしょう。
```
+-+-+-+-+-+  
| | |Q| | |    2
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
```

これもユニーク解には成り得ません。
何故なら仮に中央にあった場合、それがユニーク解であるためには少なくとも他の３辺におけるクイーンの位置も中央になければならず、それは互いの効き筋にあたるので解になりえないからです。
```
+-+-+-+-+-+  
| | |Q| | |    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
|Q| | | |Q|       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | |Q| | |      
+-+-+-+-+-+  
```

最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
```
+-+-+-+-+-+  
| | | |Q|Q|    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
```

次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
```

他の３つの角にクイーンを置くことはできないので、
```
+-+-+-+-+-+  
|Q| | | |Q|    
+-+-+-+-+-+  
| | | | | |      
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | |     
+-+-+-+-+-+  
|Q| | | |Q|      
+-+-+-+-+-+  
```

ユニーク解であるかどうかを判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになります。
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| | | |/| |      
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| | | |     
+-+-+-+-+-+  
|/| | | | |      
+-+-+-+-+-+  
```

突き詰めれば、上から２行目(row1)のクイーンの位置が右から何番目にあるかと、
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| |Q| |/| |  ←
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| | | |     
+-+-+-+-+-+  
|/| | | | |      
+-+-+-+-+-+  
```
右から２列目のクイーンの位置が上から何番目にあるかを比較するだけで判定することができます。
```
+-+-+-+-+-+  
| | | | |Q|    
+-+-+-+-+-+  
| |Q| |/| |      
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| |Q| |  ←    
+-+-+-+-+-+  
|/| | | | |      
+-+-+-+-+-+  
```
この２つの値が同じになることはないからです。
```
       3 0
+-+-+-+-+-+  
| | | | |Q| 0
+-+-+-+-+-+  
| |Q| |/| | 3    上から２行目のクイーンの位置が右から４番目にある。
+-+-+-+-+-+  
| | |/| | |       
+-+-+-+-+-+             
| |/| |Q| |  ←  右から２列目のクイーンの位置が上から４番目にある。
+-+-+-+-+-+      しかし、互いの効き筋にあたるのでこれは有り得ない。 
|/| | | | |      
+-+-+-+-+-+  
```
結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得られる解は総てユニーク解であることが保証されます。
```
+-+-+-+-+-+  
| | | |X|Q| 
+-+-+-+-+-+  
| |Q| |X| | 
+-+-+-+-+-+  
| | | |X| |       
+-+-+-+-+-+             
| | | |Q| | 
+-+-+-+-+-+ 
| | | | | |      
+-+-+-+-+-+  
```

次に右端以外にクイーンがある場合を考えてみます。
オリジナルがユニーク解であるためには先ず下図の X への配置は禁止されます。
よって、その枝刈りを先ず入れておきます。
```
+-+-+-+-+-+-+-+-+  
|X|X| | | |Q|X|X| 
+-+-+-+-+-+-+-+-+  
|X| | | | | | |X| 
+-+-+-+-+-+-+-+-+  
| | | | | | | | |       
+-+-+-+-+-+-+-+-+             
| | | | | | | | | 
+-+-+-+-+-+-+-+-+ 
| | | | | | | | |      
+-+-+-+-+-+-+-+-+  
| | | | | | | | |
+-+-+-+-+-+-+-+-+
|X| | | | | | |X|
+-+-+-+-+-+-+-+-+
|X|X| | | | |X|X|
+-+-+-+-+-+-+-+-+
```

次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。
```
+-+-+-+-+-+-+-+-+  
|X|X| | | |Q|X|X| 
+-+-+-+-+-+-+-+-+  
|X| | | |x|x|x|X| 
+-+-+-+-+-+-+-+-+  
|C| | |x| |x| |x|       
+-+-+-+-+-+-+-+-+             
| | |x| | |x| | | 
+-+-+-+-+-+-+-+-+ 
| |x| | | |x| | |      
+-+-+-+-+-+-+-+-+  
|x| | | | |x| |A|
+-+-+-+-+-+-+-+-+
|X| | | | |x| |X|
+-+-+-+-+-+-+-+-+
|X|X|B| | |x|X|X|
+-+-+-+-+-+-+-+-+
```
従って、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいことになります。


## ユニーク解を数える
これまでの考察はユニーク解の個数を求めるためのものでした。
全解数を求めるにはユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。
したがって探索時間を犠牲にしてしまうことになります。
そこで「ユニーク解の個数から全解数を導いてしまおう」という試みが考えられます。
これは、左右反転（前章のミラー）によるパターンの探索を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。
そしてそれを実現させるには「ユニーク解が属するグループの要素数はいくつあるのか」という考察が必要になってきます。

最初に、クイーンが右上角にあるユニーク解を考えます。
```
+-+-+-+-+-+  
| | | | |Q| 
+-+-+-+-+-+  
| | | | | | 
+-+-+-+-+-+  
| | | | | |       
+-+-+-+-+-+             
| | | | | | 
+-+-+-+-+-+ 
| | | | | |      
+-+-+-+-+-+  
```

斜軸で反転したパターンがオリジナルと同型になることは有り得ないことと(×２)、
```
+-+-+-+-+-+  +-+-+-+-+-+ 
| | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q|/| |  | | | |/| | 
+-+-+-+-+-+  +-+-+-+-+-+ 
| | |/| | |  | | |/|Q| | 
+-+-+-+-+-+  +-+-+-+-+-+            
| |/| | | |  | |/| | | | 
+-+-+-+-+-+  +-+-+-+-+-+ 
|/| | | | |  |/| | | | |     
+-+-+-+-+-+  +-+-+-+-+-+ 
```
右上角のクイーンを他の３つの角に写像させることができるので(×４)、
```
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | |Q|  | | | | | |  | | | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | | |  | | | | | |  | | | | | |  | | | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | | |  | | | | | |  | | | | | |  | | | | | |      
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+            
| | | | | |  | | | | | |  | | | | | |  | | | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | | | |  | | | | |Q|  |Q| | | | |  | | | | | |     
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
```

このユニーク解が属するグループの要素数は必ず８個(＝２×４)になります。

次に、クイーンが右上角以外にある場合は少し複雑になります。

(1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルから180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリジナルと同型になる。	

90度回転させても同じ場合は
```
+-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | | | |Q| | 
+-+-+-+-+-+  +-+-+-+-+-+ 
|Q| | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q| | |  | | |Q| | | 
+-+-+-+-+-+  +-+-+-+-+-+            
| | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+ 
| |Q| | | |  | |Q| | | |     
+-+-+-+-+-+  +-+-+-+-+-+ 
```

さらに90度回転（原型から180度回転）させても
```
                 さらに90度回転
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | | | |Q| |  | | | |Q| | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
|Q| | | | |  |Q| | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q| | |  | | |Q| | |  | | |Q| | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+            
| | | | |Q|  | | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| |Q| | | |  | |Q| | | |  | |Q| | | |     
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
```
さらに90度回転（原型から270度回転）させても同じ！
```
                               さらに90度回転
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | | |Q| |  | | | |Q| |  | | | |Q| |  | | | |Q| | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
|Q| | | | |  |Q| | | | |  |Q| | | | |  |Q| | | | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| | |Q| | |  | | |Q| | |  | | |Q| | |  | | |Q| | | 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+            
| | | | |Q|  | | | | |Q|  | | | | |Q|  | | | | |Q| 
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 
| |Q| | | |  | |Q| | | |  | |Q| | | |  | |Q| | | |     
+-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+  +-+-+-+-+-+ 


```
(2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナルとは異なる。
ただし、180度回転させた場合はオリジナルと同型になることも有り得る。	


## ユニーク数から全解を求める

１．クイーンが右上角にある場合、ユニーク解が属するグループの要素数は必ず８個(＝２×４)

２．クイーンが右上角以外にある場合、
  (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルから180度回転)させても、
  さらに90度回転(オリジナルから270度回転)させてもオリジナルと同型になる。	
  こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパターンを加えて２個しかありません。

  (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナルとは異なる。
  ただし、180度回転させた場合はオリジナルと同型になることも有り得る。	
  こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同型になる場合は４個(左右反転×縦横回転)

  (3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)

  １の場合は、解の数ｘ８
  ２−（１）の場合は、解の数ｘ２
  ２−（２）の場合は、解の数ｘ４
  ２−（３）の場合は、解の数ｘ８
  それぞれのグループの解の数にグループのパターン数をかけ合わせた数の総計が全解となります。
  ひとつひとつのユニーク解が上のどの種類に該当するのかを調べることにより全解数を計算で導き出すことができるのです。




## 対象解除法について
対象解除法のソースは４つの関数で構成されています。

１．printRecord()
  解を発見するたびにボードレイアウトを表示します。
  以降、新しい枝刈りポイントを発見するためにも使います。
  board[]を使ってＱの位置を確認するのに役立ちます。

２．symmetryOps()
  対象解除を行うロジックメソッドです。
  以下のロジックが同梱されています。
  
  １．クイーンが右上角にある場合、ユニーク解が属するグループの要素数は必ず８個(＝２×４)
  ２．クイーンが右上角以外にある場合、
    (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルから180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリジナルと同型になる。
    こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパターンを加えて２個しかありません。

    (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有り得る。
    こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同型になる場合は４個(左右反転×縦横回転)

    (3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)

３．backTrack()
  再帰ロジックで作られています。
  右上角にＱが配置されているかいないかで判定処理が分岐されます。
  その判定処理に従って、見合った枝刈りが行われます。

４．symmetry()
  本体メソッドです。
  こちらのメソッドでは、Ｑが角に配置されている場合、そうでない場合を分岐して３のbackTrack()に渡します。


## symmetry()メソッド
### 角にＱがある時の処理
symmetry()メソッドは、Ｑが角にあるかどうかを判定し、適切にbackTrack()に処理を渡します。

では上から順番に見ていきます。
とても大切なことなのですが、グローバル変数の初期化を行います。
``` bash
  TOTAL=UNIQUE=COUNT2=COUNT4=COUNT8=0;
```

角にＱがある時のボードのイメージは以下のとおりです。

```
  角にQがある時の処理
    +-+-+-+-+-+  
    | | | | |Q| 
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

MASKについてですが、こちらはrow全体にビットを立てて配置済みとするフィルタのことです。
Ｎ５の場合、
１０進数では３１
２進数では 11111
となります。
``` bash
MASK=$(( (1<<size)-1 ));
    +-+-+-+-+-+  
    |M|M|M|M|M|  MASK=$(( (1<<size)-1 )) 
    +-+-+-+-+-+  $(( (1<<5)-1 )):31
    | | | | | |  $(( 2#11111 )) 
    +-+-+-+-+-+  $ 31
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  ```

bashでは以下のようにすると２進数を１０進数に変換して表示することができます。
```
$ echo $(( 2#11111 ))
$ 31
```

TOPBITは左上角にビットを立てたものです。
``` bash
  TOPBIT=$(( 1<<(size-1) )); 
    +-+-+-+-+-+  
    |T| | | | |  TOPBIT=$(( 1<<(size-1) ))
    +-+-+-+-+-+  $(( (1<<(5-1) )):16 
    | | | | | |  $(( 2#10000 )) 
    +-+-+-+-+-+  $ 16 
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

ENDBITはTOPBITの１つ右にビットを立てたものです。現在はまだ初期値０のままです。
後述しますがENDBITは、
``` bash
ENDBIT=$(( TOPBIT>>1 ));
```
となります。

``` bash
  ENDBIT=LASTMASK=SIDEMASK=0;
    ０は何も置かない（なにもはじまってない）
    +-+-+-+-+-+  
    |T|E| | | |  0#01000
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

配列BOUND1とBOUND2を初期化して
Ｑを右上角に配置します。
``` bash
  BOUND1=2; BOUND2=0;
```

```
    +-+-+-+-+-+  右角から１つ左から開始
    | | | |B| |  BOUND1は右から左へシフト
    +-+-+-+-+-+   
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```
```
    +-+-+-+-+-+  左角から１つ右から開始
    | |B| | | |  BOUND2は左から右へシフトします。
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

ここはすごく重要で、row[0]の１というのは右上の角のことを意味します。ですので、「Ｑを右上角に配置した」ということになります。
``` bash
  board[0]=1;       # Qを右上角に配置
```

ここで、rowは２行目の処理に入ります。
というのも、１行目は右上角にＱを配置したので次に進んだわけです。

その後、以下の行は「２行目の真ん中にＱを配置する」という意味となります。
``` bash
      bit=$(( 1<<BOUND1 ));
```

イメージでは以下のとおりです。
```
       Ｎ５の場合、BOUND1は２と３になる
        (( 1<<BOUND1 )) ２行目は真ん中に置く
        +-+-+-+-+-+  
        | | | | |Q|  1#00001
        +-+-+-+-+-+  
        | | |B| | |  BOUND1=2 4#00100
        +-+-+-+-+-+  $(( 1<<2 ))
        | | | | | |  $ 4
        +-+-+-+-+-+  1->2->4               
        | | | | | | 
        +-+-+-+-+-+ 
        | | | | | |      
        +-+-+-+-+-+  
```

さらに、処理の中でBOUND1は左に１つシフトします。
```
        (( 1<<BOUND1 )) ２行目は真ん中の次に置く
        +-+-+-+-+-+  
        | | | | |Q|  1#00001
        +-+-+-+-+-+  
        | |B| | | |  BOUND1=3 8#01000
        +-+-+-+-+-+  $(( 1<<3 ))
        | | | | | |  $ 8
        +-+-+-+-+-+  1->2->4->8             
        | | | | | | 
        +-+-+-+-+-+ 
        | | | | | |      
        +-+-+-+-+-+  
```

### 角にＱがない時の処理
TOPBITは先程も書いたとおり、左上角にビットを立てた状態を示します。
``` bash
  TOPBIT=$(( 1<<(size-1) )); 
    +-+-+-+-+-+  
    |T| | | | | TOPBIT=$(( 1<<(size-1) ))
    +-+-+-+-+-+ $(( 2#10000 )) 
    | | | | | | $ 16 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

ENDBITは、TOPBITの１つ右にビットを立てた状態です。
``` bash
  ENDBIT=$(( TOPBIT>>1 ));
    +-+-+-+-+-+  
    |T|E| | | | ENDBIT=$(( TOPBIT>>1 ))
    +-+-+-+-+-+ $(( 2#01000 )) 
    | | | | | | $ 8
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

SIDEMASKは行の両サイドの角にビットを立てた状態を示します。
``` bash
  SIDEMASK=$(( TOPBIT|1 ));
    +-+-+-+-+-+  
    |S| | | |S| SIDEMASK=$(( TOPBIT|1 ))
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

LASTMASKもSIDEMASK同様左右の角のビットを立てた状態を示します。ただ使いみちとしては、上記の状態でも使えるわけですが、
``` bash
  LASTMASK=$(( TOPBIT|1 )); 
    +-+-+-+-+-+  
    |L| | | |L| LASTMASK=$(( TOPBIT|1 ))
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

こういうシチュエーションで使います。
``` bash
  LASTMASK=$(( TOPBIT|1 )); 
    +-+-+-+-+-+  
    | | | | | | LASTMASK=$(( TOPBIT|1 ))
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    |L| | | |L|      
    +-+-+-+-+-+  
```

ENDBITは左角の１つ手前から右へシフトするビットです。
``` bash
    ENDBIT=$(( ENDBIT>>1 ));
      +-+-+-+-+-+  
      |T|E| | | | ENDBIT=$(( TOPBIT>>1 ))
      +-+-+-+-+-+ $(( 2#01000 )) 
      | | | | | | $ 8
      +-+-+-+-+-+  
      | | | | | |       
      +-+-+-+-+-+             
      | | | | | | 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
           ↓
      +-+-+-+-+-+  
      |T| |E| | | ENDBIT=$(( ENDBIT>>1 ))
      +-+-+-+-+-+ $(( 2#00100 )) 
      | | | | | | $ 4
      +-+-+-+-+-+  
      | | | | | |       
      +-+-+-+-+-+             
      | | | | | | 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
```

LASTMASKに代入されるビットは以下のイメージとなります。使いみちはLASTMASKと似ていますが、
``` bash
    +-+-+-+-+-+  
    |L|L| |L|L| LASTMASK=$(( LASTMASK<<1 | LASTMASK | LASTMASK>>1 ))
    +-+-+-+-+-+ $(( 2#11011 )) 
    | | | | | | $ 27
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
```

こういったシチュエーションにも使います。
``` bash
    +-+-+-+-+-+  
    | | | | | | LASTMASK=$(( LASTMASK<<1 | LASTMASK | LASTMASK>>1 ))
    +-+-+-+-+-+ $(( 2#11011 )) 
    | | | | | | $ 27
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    |L|L| |L|L|      
    +-+-+-+-+-+  
```

### symmetry()メソッドのソース
symmetry()のソースは以下のとおりです。
``` bash
# 再帰・非再帰版 対象解除
function symmetry()
{
  TOTAL=UNIQUE=COUNT2=COUNT4=COUNT8=0;
  角にQがある時の処理
    +-+-+-+-+-+  
    | | | | |Q| 
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  MASK=$(( (1<<size)-1 ));
    +-+-+-+-+-+  
    |M|M|M|M|M|  MASK=$(( (1<<size)-1 )) 
    +-+-+-+-+-+  $(( (1<<5)-1 )):31
    | | | | | |  $(( 2#11111 )) 
    +-+-+-+-+-+  $ 31
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  TOPBIT=$(( 1<<(size-1) )); 
    +-+-+-+-+-+  
    |T| | | | |  TOPBIT=$(( 1<<(size-1) ))
    +-+-+-+-+-+  $(( (1<<(5-1) )):16 
    | | | | | |  $(( 2#11111 )) 
    +-+-+-+-+-+  $ 16 
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  ENDBIT=LASTMASK=SIDEMASK=0;
    ０は何も置かない（なにもはじまってない）
    +-+-+-+-+-+  
    | | | | | |  0#00000
    +-+-+-+-+-+  
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  BOUND1=2; BOUND2=0;
  board[0]=1;
  while (( BOUND1>1 && BOUND1<size-1 ));do
    if (( BOUND1<size-1 ));then
      bit=$(( 1<<BOUND1 ));
       Ｎ５の場合、BOUND1は２と３になる
        (( 1<<BOUND1 )) ２行目は真ん中に置く
        +-+-+-+-+-+  
        | | | | |Q|  1#00001
        +-+-+-+-+-+  
        | | |B| | |  BOUND1=2 4#00100
        +-+-+-+-+-+  $(( 1<<2 ))
        | | | | | |  $ 4
        +-+-+-+-+-+  1->2->4               
        | | | | | | 
        +-+-+-+-+-+ 
        | | | | | |      
        +-+-+-+-+-+  
        (( 1<<BOUND1 )) ２行目は真ん中の次に置く
        +-+-+-+-+-+  
        | | | | |Q|  1#00001
        +-+-+-+-+-+  
        | |B| | | |  BOUND1=3 8#01000
        +-+-+-+-+-+  $(( 1<<3 ))
        | | | | | |  $ 8
        +-+-+-+-+-+  1->2->4->8             
        | | | | | | 
        +-+-+-+-+-+ 
        | | | | | |      
        +-+-+-+-+-+  
      board[1]="$bit";          # ２行目にQを配置
      backTrack "2" "$(( (2|bit)<<1 ))" "$(( 1|bit ))" "$(( bit>>1 ))" "1";
    fi
    (( BOUND1++ ));
  done
  角にQがない時の処理
    +-+-+-+-+-+  
    | | | |Q| | $(( 2#00010 ))
    +-+-+-+-+-+ $ 2 
    | | | | | | 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  TOPBIT=$(( 1<<(size-1) )); 
    +-+-+-+-+-+  
    |T| | | | | TOPBIT=$(( 1<<(size-1) ))
    +-+-+-+-+-+ $(( 2#10000 )) 
    | | | | | | $ 16 
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  ENDBIT=$(( TOPBIT>>1 ));
    +-+-+-+-+-+  
    |T|E| | | | ENDBIT=$(( TOPBIT>>1 ))
    +-+-+-+-+-+ $(( 2#01000 )) 
    | | | | | | $ 8
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  SIDEMASK=$(( TOPBIT|1 ));
    +-+-+-+-+-+  
    |S| | | |S| SIDEMASK=$(( TOPBIT|1 ))
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  LASTMASK=$(( TOPBIT|1 )); 
    +-+-+-+-+-+  
    |L| | | |L| LASTMASK=$(( TOPBIT|1 ))
    +-+-+-+-+-+ $(( 2#10001 )) 
    | | | | | | $ 17
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  BOUND1=1; 
  BOUND2=size-2;
  while (( BOUND1>0 && BOUND2<size-1 && BOUND1<BOUND2 ));do
    if (( BOUND1<BOUND2 ));then
      bit=$(( 1<<BOUND1 ));
      board[0]="$bit";          # Qを配置
      backTrack "1" "$(( bit<<1 ))" "$bit" "$(( bit>>1 ))" "0";
    fi 
    (( BOUND1++,BOUND2-- ));
    ENDBIT=$(( ENDBIT>>1 ));
      +-+-+-+-+-+  
      |T|E| | | | ENDBIT=$(( TOPBIT>>1 ))
      +-+-+-+-+-+ $(( 2#01000 )) 
      | | | | | | $ 8
      +-+-+-+-+-+  
      | | | | | |       
      +-+-+-+-+-+             
      | | | | | | 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
           ↓
      +-+-+-+-+-+  
      |T| |E| | | ENDBIT=$(( ENDBIT>>1 ))
      +-+-+-+-+-+ $(( 2#00100 )) 
      | | | | | | $ 4
      +-+-+-+-+-+  
      | | | | | |       
      +-+-+-+-+-+             
      | | | | | | 
      +-+-+-+-+-+ 
      | | | | | |      
      +-+-+-+-+-+  
    LASTMASK=$(( LASTMASK<<1 | LASTMASK | LASTMASK>>1 )) ;
    +-+-+-+-+-+  
    |L|L| |L|L| LASTMASK=$(( LASTMASK<<1 | LASTMASK | LASTMASK>>1 ))
    +-+-+-+-+-+ $(( 2#11011 )) 
    | | | | | | $ 27
    +-+-+-+-+-+  
    | | | | | |       
    +-+-+-+-+-+             
    | | | | | | 
    +-+-+-+-+-+ 
    | | | | | |      
    +-+-+-+-+-+  
  done
  UNIQUE=$(( COUNT8+COUNT4+COUNT2 )) ;
  TOTAL=$(( COUNT8*8+COUNT4*4+COUNT2*2 ));
}
#
```

##  backTrack()メソッド
### Ｑが角にある時の処理
このメソッドでは、角にＱがある場合の処理、ない場合の処理の分岐があり、その分岐の中で、`((COUNT8++))`であったり、`symmetryOps`といった対象解除の処理へ進んだり、はたまた「枝刈り」をしたりと、濃厚なメソッドです。

では、順番に見ていきます。

ここは、Ｑが角にある場合の処理で、rowが最終行までたどり着いた（配置できた）場合の処理となります。グループの要素数は必ず８あるわけですので、あとから８倍する`COUNT8`をインクリメントします。
``` bash
        １．クイーンが右上角にある場合、ユニーク解が属する
        グループの要素数は必ず８個(＝２×４)
        board[$row]="$bitmap";
        if ((DISPLAY==1));then
          printRecord "$size" 1 ;
        fi
        ((COUNT8++)) ;              # 角にある場合は８倍するカウンター
```

次は、Ｑが角にある場合の処理で、
        上から２行目のクイーンの位置が左から何番目にあるかと、
        右から２列目のクイーンの位置が上から何番目にあるかを、
        比較するだけで判定します。
        具体的には、２行目と２列目の位置を数値とみなし、
        ２行目＜２列目という条件を課せばよい
という枝仮ルールを実現している処理となります。
``` bash
    if (( corner ));then            # Qが角にある
      if ((row<BOUND1));then        # 枝刈り
         bitmap=$(( bitmap|2 ));
         bitmap=$(( bitmap^2 ));
        上から２行目のクイーンの位置が左から何番目にあるかと、
        右から２列目のクイーンの位置が上から何番目にあるかを、
        比較するだけで判定します。
        具体的には、２行目と２列目の位置を数値とみなし、
        ２行目＜２列目という条件を課せばよい
        結論： 以下の図では、１，２，４を枝刈りを入れる
          
          +-+-+-+-+-+  
          | | | |X|Q| 
          +-+-+-+-+-+  
          | |Q| |X| |  8（左から数えて１，２，４，８）
          +-+-+-+-+-+  
          | | | |X| |       
          +-+-+-+-+-+             
          | | | |Q| |  8（上から数えて１，２，４，８） 
          +-+-+-+-+-+ 
          | | | | | |      
          +-+-+-+-+-+  
      fi

```

たったこれだけの２行ですごいですね。
``` bash
         bitmap=$(( bitmap|2 ));
         bitmap=$(( bitmap^2 ));
```

### 角にＱがない時の処理
ここは少しわかりにくいですね。丁寧に説明文を入れましたので、じっくりと理解してみてください。
``` bash
    else                            # Qが角にない
      オリジナルがユニーク解であるためには先ず、
      前提：symmetryOpsは回転・鏡像変換により得られる状態の
      ユニーク値を比較し最小のものだけがユニーク解となるようにしている。
      Qができるだけ右に置かれている方がユニーク値は小さい。
      例えば1行目の2列目にQが置かれている方が3列目に置かれているより
      ユニーク値は小さくユニーク解に近い。
      1行目のクイーンの位置が同じなら2行目のクイーンの位置がより右の
      列におかれているものがユニーク値は小さくユニーク解に近い。

      下図の X への配置は禁止されます。
      Qの位置より右位置の８対象位置（X）にクイーンを置くことはできない。
      置いた場合回転・鏡像変換したユニーク値が最小にならなくなり、symmetryOps
      で負けるので枝刈りをする


      1行目のクイーンが3列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X| | | |Q|X|X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X| 
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |
      +-+-+-+-+-+-+-+-+
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X|X| | | | |X|X|
      +-+-+-+-+-+-+-+-+

      1行目のクイーンが4列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X|X| |Q|X|X|X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X|       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X|X|X| | |X|X|X|
      +-+-+-+-+-+-+-+-+

      プログラムではこの枝刈を上部サイド枝刈り、下部サイド枝刈り、最下段枝刈り
      の3か所で行っている
      それぞれ、1,2,3の数字で表すと以下の通り

      1行目のクイーンが3列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X| | | |Q|X|X| 
      +-+-+-+-+-+-+-+-+  
      |1| | | | | | |1| 
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |
      +-+-+-+-+-+-+-+-+
      |2| | | | | | |2|
      +-+-+-+-+-+-+-+-+
      |2|3| | | | |3|2|
      +-+-+-+-+-+-+-+-+
      1行目にXが残っているが当然Qの効き筋なので枝刈する必要はない
      if ((row<BOUND1));then        # 上部サイド枝刈り
        bitmap=$(( bitmap|SIDEMASK ));
        bitmap=$(( bitmap^=SIDEMASK ));
      fi
      if ((row==BOUND2));then       # 下部サイド枝刈り
        if (( !(down&SIDEMASK) ));then
          return ;
        fi
        if (( (down&SIDEMASK)!=SIDEMASK ));then
          bitmap=$(( bitmap&SIDEMASK ));
        fi
      fi
    fi
```

### backTrack()メソッドのソース
backTrack()のソースは以下のとおりです。
``` bash
# 再帰版対象解除バックトラック
function backTrack()
{
  local row=$1;
  local left=$2;
  local down=$3;
  local right=$4; 
  local corner=$5;                  # Qが角にある:1 ない:0
  local bitmap=$(( MASK&~(left|down|right) ));
  if ((row==(size-1) ));then
    if ((bitmap));then
      if ((corner));then            # Qが角にある
        １．クイーンが右上角にある場合、ユニーク解が属する
        グループの要素数は必ず８個(＝２×４)
        board[$row]="$bitmap";
        if ((DISPLAY==1));then
          printRecord "$size" 1 ;
        fi
        ((COUNT8++)) ;              # 角にある場合は８倍するカウンター
      else                          # Qが角にない
        if (( !(bitmap&LASTMASK) ));then
          board[$row]="$bitmap";     # Qを配置
          symmetryOps ;             # 対象解除
        fi
      fi
    fi
  else
    if (( corner ));then            # Qが角にある
      if ((row<BOUND1));then        # 枝刈り
         bitmap=$(( bitmap|2 ));
         bitmap=$(( bitmap^2 ));
        上から２行目のクイーンの位置が左から何番目にあるかと、
        右から２列目のクイーンの位置が上から何番目にあるかを、
        比較するだけで判定します。
        具体的には、２行目と２列目の位置を数値とみなし、
        ２行目＜２列目という条件を課せばよい
        結論： 以下の図では、１，２，４を枝刈りを入れる
          
          +-+-+-+-+-+  
          | | | |X|Q| 
          +-+-+-+-+-+  
          | |Q| |X| |  8（左から数えて１，２，４，８）
          +-+-+-+-+-+  
          | | | |X| |       
          +-+-+-+-+-+             
          | | | |Q| |  8（上から数えて１，２，４，８） 
          +-+-+-+-+-+ 
          | | | | | |      
          +-+-+-+-+-+  
      fi
    else                            # Qが角にない
      オリジナルがユニーク解であるためには先ず、
      前提：symmetryOpsは回転・鏡像変換により得られる状態の
      ユニーク値を比較し最小のものだけがユニーク解となるようにしている。
      Qができるだけ右に置かれている方がユニーク値は小さい。
      例えば1行目の2列目にQが置かれている方が3列目に置かれているより
      ユニーク値は小さくユニーク解に近い。
      1行目のクイーンの位置が同じなら2行目のクイーンの位置がより右の
      列におかれているものがユニーク値は小さくユニーク解に近い。

      下図の X への配置は禁止されます。
      Qの位置より右位置の８対象位置（X）にクイーンを置くことはできない。
      置いた場合回転・鏡像変換したユニーク値が最小にならなくなり、symmetryOps
      で負けるので枝刈りをする


      1行目のクイーンが3列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X| | | |Q|X|X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X| 
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |
      +-+-+-+-+-+-+-+-+
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X|X| | | | |X|X|
      +-+-+-+-+-+-+-+-+

      1行目のクイーンが4列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X|X| |Q|X|X|X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X| 
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X|       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X| | | | | | |X|
      +-+-+-+-+-+-+-+-+
      |X|X|X| | |X|X|X|
      +-+-+-+-+-+-+-+-+

      プログラムではこの枝刈を上部サイド枝刈り、下部サイド枝刈り、最下段枝刈り
      の3か所で行っている
      それぞれ、1,2,3の数字で表すと以下の通り

      1行目のクイーンが3列目に置かれている場合
      +-+-+-+-+-+-+-+-+  
      |X|X| | | |Q|X|X| 
      +-+-+-+-+-+-+-+-+  
      |1| | | | | | |1| 
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |       
      +-+-+-+-+-+-+-+-+             
      | | | | | | | | | 
      +-+-+-+-+-+-+-+-+ 
      | | | | | | | | |      
      +-+-+-+-+-+-+-+-+  
      | | | | | | | | |
      +-+-+-+-+-+-+-+-+
      |2| | | | | | |2|
      +-+-+-+-+-+-+-+-+
      |2|3| | | | |3|2|
      +-+-+-+-+-+-+-+-+
      1行目にXが残っているが当然Qの効き筋なので枝刈する必要はない
      if ((row<BOUND1));then        # 上部サイド枝刈り
        bitmap=$(( bitmap|SIDEMASK ));
        bitmap=$(( bitmap^=SIDEMASK ));
      fi
      if ((row==BOUND2));then       # 下部サイド枝刈り
        if (( !(down&SIDEMASK) ));then
          return ;
        fi
        if (( (down&SIDEMASK)!=SIDEMASK ));then
          bitmap=$(( bitmap&SIDEMASK ));
        fi
      fi
    fi
    while((bitmap));do
      bit=$(( -bitmap & bitmap )) ;
      bitmap=$(( bitmap^bit));
      board[$row]="$bit"             # Qを配置
      backTrack $((row+1)) $(((left|bit)<<1))  $((down|bit)) $(((right|bit)>>1)) "$corner" ;
    done
  fi
}
#
```

## symmetryOps()メソッド
ここもロジックを理解するところから初めて見ると良いと思います。
あまり細かいことを考えるよりも、大枠でどんなときにこのメソッドが呼ばれ、カウンターがいつインクリメントするのか、などを掴んだほうが良いと思います。

symmetryOps()では以下を実現しています。

  ２．クイーンが右上角以外にある場合、
  (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
  ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
  ジナルと同型になる。
  こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパター
  ンを加えて２個しかありません。
  ２．クイーンが右上角以外にある場合、
    (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナル
    とは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有り得
    る。こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同
    型になる場合は４個(左右反転×縦横回転)
  ２．クイーンが右上角以外にある場合、
    (3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)


  クイーンの利き筋を辿っていくと、オリジナルがユニーク解ではない可能性があり、
  それは下図の A,B,C の位置のどこかにクイーンがある場合に限られます。
  symmetryOpsは、以下の図のＡ，Ｂ，ＣにＱが置かれた場合にユニーク解かを判定します。
  原型と、90,180,270回転させたもののユニーク値を比較します。

     0 1 2 3 4 
    +-+-+-+-+-+  
    | | | | |Q|    4
    +-+-+-+-+-+  
    | | |Q| | |    2 
    +-+-+-+-+-+  
    |Q| | | | |    0  ----> 4 2 0 3 1 （ユニーク判定値）
    +-+-+-+-+-+             数が大きい方をユニークとみなす 
    | | | |Q| |    3
    +-+-+-+-+-+  
    | |Q| | | |    1 
    +-+-+-+-+-+  

     0 1 2 3 4     左右反転！
    +-+-+-+-+-+  
    |Q| | | | |    0
    +-+-+-+-+-+  
    | | |Q| | |    2 
    +-+-+-+-+-+  
    | | | | |Q|    4  ----> 0 2 4 1 3 
    +-+-+-+-+-+            数が小さいのでユニーク解とはしません 
    | |Q| | | |    1
    +-+-+-+-+-+  
    | | | |Q| |    3 
    +-+-+-+-+-+  

  Qができるだけ右に置かれている方がユニーク値は大きくなります。
  例えば1行目の2列目にQが置かれている方が、
  3列目に置かれているよりユニーク値は大きくユニーク解に近い。
  1行目のクイーンの位置が同じなら2行目のクイーンの位置がより右の列におかれてい
  るものがユニーク値は大きくユニーク解に近くなります。

  それ以外はユニーク解なのでCOUNT8にする
   +-+-+-+-+-+-+-+-+  
   |X|X| | | |Q|X|X| 
   +-+-+-+-+-+-+-+-+  
   |X| | | |x|x|x|X| 
   +-+-+-+-+-+-+-+-+  
   |C| | |x| |x| |x|       
   +-+-+-+-+-+-+-+-+             
   | | |x| | |x| | | 
   +-+-+-+-+-+-+-+-+ 
   | |x| | | |x| | |      
   +-+-+-+-+-+-+-+-+  
   |x| | | | |x| |A|
   +-+-+-+-+-+-+-+-+
   |X| | | | |x| |X|
   +-+-+-+-+-+-+-+-+
   |X|X|B| | |x|X|X|
   +-+-+-+-+-+-+-+-+
   
   Aの場合 右90度回転   board[BOUND2]==1
   Bの場合 右180度回転  board[size-1]==ENDBIT
   Cの場合 右270度回転  board[BOUND1]==TOPBIT
';

# グローバル変数
declare -i size;
declare -a board;
declare -i bit;
declare -i DISPLAY=0;   # ボード出力するか
declare -i TOTAL=UNIQUE=0;
declare -i COUNT2=COUNT4=COUNT8=0;
declare -i MASK=SIDEMASK=LASTMASK=0;
declare -i TOPBIT=ENDBIT=0;
declare -i BOUND1=BOUND2=0;
#
: 'ボードレイアウトを出力 ビットマップ対応版';
function printRecord()
{
  ((TOTAL++));
  size="$1";
  flag="$2"; # bitmap版は1 それ以外は 0
  echo "$TOTAL";
  sEcho=" ";  
  : 'ビットマップ版
     ビットマップ版からは、左から数えます
     上下反転左右対称なので、これまでの上から数える手法と
     rowを下にたどって左から数える方法と解の数に変わりはありません。
     0 2 4 1 3 
    +-+-+-+-+-+
    |O| | | | | 0
    +-+-+-+-+-+
    | | |O| | | 2
    +-+-+-+-+-+
    | | | | |O| 4
    +-+-+-+-+-+
    | |O| | | | 1
    +-+-+-+-+-+
    | | | |O| | 3
    +-+-+-+-+-+
  ';
  if ((flag));then
    local -i i=0;
    local -i j=0;
    for ((i=0;i<size;i++));do
      for ((j=0;j<size;j++));do
       if (( board[i]&1<<j ));then
          sEcho="${sEcho}$((j)) ";
       fi 
      done
    done
  else 
  : 'ビットマップ版以外
     (ブルートフォース、バックトラック、配置フラグ)
     上から数えます
     0 2 4 1 3 
    +-+-+-+-+-+
    |O| | | | |
    +-+-+-+-+-+
    | | | |O| |
    +-+-+-+-+-+
    | |O| | | |
    +-+-+-+-+-+
    | | | | |O|
    +-+-+-+-+-+
    | | |O| | |
    +-+-+-+-+-+

     ';
    local -i i=0;
    for((i=0;i<size;i++)){
      sEcho="${sEcho}${board[i]} ";
    }
  fi
  echo "$sEcho";
  echo -n "+";
  local -i i=0;
  for((i=0;i<size;i++)){
    echo -n "-";
    if((i<(size-1)));then
      echo -n "+";
    fi
  }
  echo "+";
  local -i i=0;
  local -i j=0;
  for((i=0;i<size;i++)){
    echo -n "|";
    for((j=0;j<size;j++)){
      if ((flag));then
        if (( board[i]&1<<j ));then
          echo -n "Q";
        else
          echo -n " ";
        fi
      else
        if((i==board[j]));then
          echo -n "Q";
        else
          echo -n " ";
        fi
      fi
      if((j<(size-1)));then
        echo -n "|";
      fi
    }
  echo "|";
  if((i<(size-1)));then
    echo -n "+";
    local -i j=0;
    for((j=0;j<size;j++)){
      echo -n "-";
      if((j<(size-1)));then
        echo -n "+";
      fi
    }
  echo "+";
  fi
  }
  echo -n "+";
  local -i i=0;
  for((i=0;i<size;i++)){
    echo -n "-";
    if((i<(size-1)));then
      echo -n "+";
    fi
  }  
  echo "+";
  echo "";
}
#
: '再帰・非再帰版 対象解除法';
function symmetryOps()
{
  : '
  ２．クイーンが右上角以外にある場合、
  (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
  ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
  ジナルと同型になる。
  こちらに該当するユニーク解が属するグループの要素数は、左右反転させたパター
  ンを加えて２個しかありません。
  ';
  ((board[BOUND2]==1))&&{
    for((ptn=2,own=1;own<=size-1;own++,ptn<<=1)){
      for((bit=1,you=size-1;(board[you]!=ptn)&&(board[own]>=bit);you--)){
        ((bit<<=1));
      }
      ((board[own]>bit))&& return ;
      ((board[own]<bit))&& break ;
    }
    #90度回転して同型なら180度回転も270度回転も同型である
    ((own>size-1))&&{ 
      ((COUNT2++)); 
      if ((DISPLAY==1));then
        # 出力 1:bitmap版 0:それ以外
        printRecord "$size" "1";          
      fi
      return; 
    }
  }
  : '
  ２．クイーンが右上角以外にある場合、
    (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナル
    とは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有り得
    る。こちらに該当するユニーク解が属するグループの要素数は、180度回転させて同
    型になる場合は４個(左右反転×縦横回転)
  ';
  #180度回転
  ((board[size-1]==ENDBIT))&&{ 
    for ((you=size-1-1,own=1;own<=size-1;own++,you--)){
      for ((bit=1,ptn=TOPBIT;(ptn!=board[you])&&(board[own]>=bit);ptn>>=1)){
          ((bit<<=1)) ;
        }
      ((board[own]>bit))&& return ;
      ((board[own]<bit))&& break ;
    }
    #90度回転が同型でなくても180度回転が同型であることもある
    ((own>size-1))&&{ 
      ((COUNT4++)); 
      if ((DISPLAY==1));then
        # 出力 1:bitmap版 0:それ以外
        printRecord "$size" "1";          
      fi
      return; 
    }
  }
  : '
  ２．クイーンが右上角以外にある場合、
    (3)180度回転させてもオリジナルと異なる場合は、８個(左右反転×縦横回転×上下反転)
  ';
  #270度回転
  ((board[BOUND1]==TOPBIT))&&{ 
    for((ptn=TOPBIT>>1,own=1;own<=size-1;own++,ptn>>=1)){
      for((bit=1,you=0;(board[you]!=ptn)&&(board[own]>=bit);you++)){
          ((bit<<=1)) ;
        }
      ((board[own]>bit))&& return ;
      ((board[own]<bit))&& break ;
    }
  }
  ((COUNT8++));
  if ((DISPLAY==1));then
    # 出力 1:bitmap版 0:それ以外
    printRecord "$size" "1";          
  fi
}
#
: '非再帰版 角にQがない時の対象解除バックトラック';
function symmetry_backTrack_NR()
{
  local -i row="$1";
  local -i MASK="$(( (1<<size)-1 ))";
  local -a bitmap[$size];
  local -a left[$size];
  local -a down[$size];
  local -a right[$size];
  local -i bit=0;
  left[$row]="$2";
  down[$row]="$3";
  right[$row]="$4";
  bitmap[$row]=$(( MASK&~(left[row]|down[row]|right[row]) ));
  while ((row>=1));do
    if (( bitmap[row]>0 ));then
      if ((row<BOUND1));then         #上部サイド枝刈り
        bitmap[$row]=$(( bitmap[row]|SIDEMASK ));
        bitmap[$row]=$(( bitmap[row]^SIDEMASK ));
      elif ((row==BOUND2));then      #下部サイド枝刈り
        #if (( (down[row]&SIDEMASK) ==0));then
        #  ((row--));
        #fi
        if (((down[row]&SIDEMASK)!=SIDEMASK));then
          bitmap[$row]=$(( bitmap[row]&SIDEMASK ));
        fi
      fi
      # 一番右のビットを取り出す
      save_bitmap=${bitmap[row]}
      bit=$(( -bitmap[row]&bitmap[row] ));  
      # 配置可能なパターンが一つずつ取り出される
      bitmap[$row]=$(( bitmap[row]^bit ));  
      board[$row]="$bit";            # Qを配置
      if (( row==(size-1) ));then
        if(((save_bitmap&LASTMASK)==0));then
          echo "sssss"
          symmetryOps ;
        fi
        ((row--));
      else
        local -i n=$((row++));
        left[$row]=$(((left[n]|bit)<<1));
        down[$row]=$(((down[n]|bit)));
        right[$row]=$(((right[n]|bit)>>1));
        # クイーンが配置可能な位置を表す
        bitmap[$row]=$(( MASK&~(left[row]|down[row]|right[row]) ));
      fi
    else
      ((row--));
    fi
  done
}
#
: '非再帰版 角にQがある時の対象解除バックトラック';
function symmetry_backTrack_corner_NR()
{
  local -i row="$1";
  local -i MASK="$(( (1<<size)-1 ))";
  local -a bitmap[$size];
  local -a left[$size];
  local -a down[$size];
  local -a right[$size];
  local -i bit=0;
  left[$row]="$2";
  down[$row]="$3";
  right[$row]="$4";
  bitmap[$row]=$(( MASK&~(left[row]|down[row]|right[row]) ));
  while ((row>=2));do
    if ((row<BOUND1));then
      bitmap[$row]=$(( bitmap[row]|2 ));
      bitmap[$row]=$(( bitmap[row]^2 ));
    fi
    if (( bitmap[row]>0 ));then
      bit=$(( -bitmap[row]&bitmap[row] ));  # 一番右のビットを取り出す
      bitmap[$row]=$(( bitmap[row]^bit ));  # 配置可能なパターンが一つずつ取り出される
      board[$row]="$bit";                   # Qを配置
      if (( row==(size-1) ));then
          #枝刈りによりsymmetryOpsは不要
          #symmetryOps ;
          ((CO++)) ;
          ((COUNT8++)) ;
          if ((DISPLAY==1));then
            # 出力 1:bitmap版 0:それ以外
            printRecord "$size" "1";          
          fi
        ((row--));
      else
        local -i n=$((row++));
        left[$row]=$(((left[n]|bit)<<1));
        down[$row]=$(((down[n]|bit)));
        right[$row]=$(((right[n]|bit)>>1));
        # クイーンが配置可能な位置を表す
        bitmap[$row]=$(( MASK&~(left[row]|down[row]|right[row]) ));
      fi
    else
      ((row--));
    fi
  done
}
#
: '非再帰版 対象解除';
function symmetry_NR()
{
  TOTAL=UNIQUE=COUNT2=COUNT4=COUNT8=0;
  MASK=$(( (1<<size)-1 ));
  TOPBIT=$(( 1<<(size-1) )); 
  ENDBIT=LASTMASK=SIDEMASK=0;
  BOUND1=2; BOUND2=0;
  board[0]=1;
  while (( BOUND1>1 && BOUND1<size-1 ));do
    if (( BOUND1<size-1 ));then
      bit=$(( 1<<BOUND1 ));
      board[1]="$bit";          # ２行目にQを配置
      # 角にQがある時のバックトラック
      symmetry_backTrack_corner_NR "2" "$(( (2|bit)<<1 ))" "$(( 1|bit ))" "$(( (bit)>>1 ))";
    fi
    (( BOUND1++ ));
  done
  TOPBIT=$(( 1<<(size-1) )); 
  ENDBIT=$(( TOPBIT>>1 ));
  SIDEMASK=$(( TOPBIT|1 ));
  LASTMASK=$(( TOPBIT|1 )); 
  BOUND1=1; 
  BOUND2=$size-2;
  while (( BOUND1>0 && BOUND2<size-1 && BOUND1<BOUND2 ));do
    if (( BOUND1<BOUND2 ));then
      bit=$(( 1<<BOUND1 ));
      board[0]="$bit";          # Qを配置
      # 角にQがない時のバックトラック
      symmetry_backTrack_NR "1" "$(( bit<<1 ))" "$bit" "$(( bit>>1 ))";
    fi 
    (( BOUND1++,BOUND2-- ));
    ENDBIT=$(( ENDBIT>>1 ));
    LASTMASK=$(( LASTMASK<<1 | LASTMASK | LASTMASK>>1 )) ;
  done
  UNIQUE=$(( COUNT8+COUNT4+COUNT2 )) ;
  TOTAL=$(( COUNT8*8+COUNT4*4+COUNT2*2 ));
}
#
: '再帰版 角にQがない時の対象解除バックトラック';
function symmetry_backTrack()
{
  local row=$1;
  local left=$2;
  local down=$3;
  local right=$4; 
  local bitmap=$(( MASK&~(left|down|right) ));
  if ((row==(size-1) ));then
    if ((bitmap));then
      if (( !(bitmap&LASTMASK) ));then
        board[$row]="$bitmap";     # Qを配置
        symmetryOps ;             # 対象解除
      fi
    fi
  else
    if ((row<BOUND1));then        # 上部サイド枝刈り
      bitmap=$(( bitmap|SIDEMASK ));
      bitmap=$(( bitmap^SIDEMASK ));
    else 
      if ((row==BOUND2));then     # 下部サイド枝刈り
        if (( !(down&SIDEMASK) ));then
          return ;
        fi
        if (( (down&SIDEMASK)!=SIDEMASK ));then
          bitmap=$(( bitmap&SIDEMASK ));
        fi
      fi
    fi
    while((bitmap));do
      bit=$(( -bitmap & bitmap )) ;
      bitmap=$(( bitmap^bit));
      board[$row]="$bit"             # Qを配置
      symmetry_backTrack $((row+1)) $(((left|bit)<<1))  $((down|bit)) $(((right|bit)>>1));
    done
  fi
}
#
: '再帰版 角にQがある時の対象解除バックトラック';
function symmetry_backTrack_corner()
{
  local row=$1;
  local left=$2;
  local down=$3;
  local right=$4; 
  local bitmap=$(( MASK&~(left|down|right) ));
  if ((row==(size-1) ));then
    if ((bitmap));then
      board[$row]="$bitmap";
      if ((DISPLAY==1));then
        printRecord "$size" 1 ;
      fi
      ((COUNT8++)) ;              
      ((CO++)) ;              
    fi
  else
    if ((row<BOUND1));then        # 枝刈り
      bitmap=$(( bitmap|2 ));
      bitmap=$(( bitmap^2 ));
    fi
    while((bitmap));do
      bit=$(( -bitmap & bitmap )) ;
      bitmap=$(( bitmap^bit));
      board[$row]="$bit"           # Qを配置
      symmetry_backTrack_corner $((row+1)) $(((left|bit)<<1))  $((down|bit)) $(((right|bit)>>1));
    done
  fi
}
#
: '再帰版 対象解除';
function symmetry()
{
  TOTAL=UNIQUE=COUNT2=COUNT4=COUNT8=0;
  MASK=$(( (1<<size)-1 ));
  TOPBIT=$(( 1<<(size-1) )); 
  ENDBIT=LASTMASK=SIDEMASK=0;
  BOUND1=2; BOUND2=0;
  board[0]=1;
  while (( BOUND1>1 && BOUND1<size-1 ));do
    if (( BOUND1<size-1 ));then
      bit=$(( 1<<BOUND1 ));
      board[1]="$bit";          # ２行目にQを配置
      # 角にQがある時のバックトラック
      symmetry_backTrack_corner "2" "$(( (2|bit)<<1 ))" "$(( 1|bit ))" "$(( (2|bit)>>1 ))";
    fi
    (( BOUND1++ ));
  done
  TOPBIT=$(( 1<<(size-1) )); 
  ENDBIT=$(( TOPBIT>>1 ));
  SIDEMASK=$(( TOPBIT|1 ));
  LASTMASK=$(( TOPBIT|1 )); 
  BOUND1=1; 
  BOUND2=$size-2;
  while (( BOUND1>0 && BOUND2<size-1 && BOUND1<BOUND2 ));do
    if (( BOUND1<BOUND2 ));then
      bit=$(( 1<<BOUND1 ));
      board[0]="$bit";          # Qを配置
      # 角にQがない時のバックトラック
      symmetry_backTrack "1" "$(( bit<<1 ))" "$bit" "$(( bit>>1 ))";
    fi 
    (( BOUND1++,BOUND2-- ));
    ENDBIT=$(( ENDBIT>>1 ));
    LASTMASK=$(( LASTMASK<<1 | LASTMASK | LASTMASK>>1 )) ;
  done
  UNIQUE=$(( COUNT8+COUNT4+COUNT2 )) ;
  TOTAL=$(( COUNT8*8+COUNT4*4+COUNT2*2 ));
}
#
# 実行 
DISPLAY=0; # DISPLAY表示をしない
#DISPLAY=1;# DISPLAY表示をする

# size=5;
# #symmetry ;   # 再帰
# symmetry_NR ; # 非再帰
# echo "SIZE:$size TOTAL:$TOTAL UNIQUE:$UNIQUE";
# echo "COUNT2:$COUNT2 COUNT4:$COUNT4 COUNT8:$COUNT8";

CO=0;
size=9;
symmetry ;   # 再帰
#symmetry_NR ; # 非再帰
echo "SIZE:$size TOTAL:$TOTAL UNIQUE:$UNIQUE";
echo "COUNT2:$COUNT2 COUNT4:$COUNT4 COUNT8:$COUNT8";
echo "$CO"

