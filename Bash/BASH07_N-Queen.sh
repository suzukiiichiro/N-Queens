#!/bin/bash
#
#
# Bash（シェルスクリプト）で学ぶ「アルゴリズムとデータ構造」
# 一般社団法人  共同通信社  情報技術局  鈴木  維一郎(suzuki.iichiro@kyodonews.jp)
#
#
# ---------------------------------------------------------------------------------
##
# ７．バックトラック＋ビットマップ＋対称解除法
#
#     一つの解には、盤面を９０度、１８０度、２７０度回転、及びそれらの鏡像の合計
#     ８個の対称解が存在する。対照的な解を除去し、ユニーク解から解を求める手法。
# 
# ■ユニーク解の判定方法
#   全探索によって得られたある１つの解が、回転・反転などによる本質的に変わること
# のない変換によって他の解と同型となるものが存在する場合、それを別の解とはしない
# とする解の数え方で得られる解を「ユニーク解」といいます。つまり、ユニーク解とは、
# 全解の中から回転・反転などによる変換によって同型になるもの同士をグループ化する
# ことを意味しています。
# 
#   従って、ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、こ
# の解はユニーク解ではないという定まった判定方法はありません。ユニーク解であるか
# どうかの判断はユニーク解の個数を数える目的の為だけに各個人が自由に定義すること
# になります。もちろん、どのような定義をしたとしてもユニーク解の個数それ自体は変
# わりません。
# 
#   さて、Ｎクイーン問題は正方形のボードで形成されるので回転・反転による変換パター
# ンはぜんぶで８通りあります。だからといって「全解数＝ユニーク解数×８」と単純には
# いきません。ひとつのグループの要素数が必ず８個あるとは限らないのです。Ｎ＝５の
# 下の例では要素数が２個のものと８個のものがあります。
#
#
# Ｎ＝５の全解は１０、ユニーク解は２なのです。
# 
# グループ１: ユニーク解１つ目
# - - - Q -   - Q - - -
# Q - - - -   - - - - Q
# - - Q - -   - - Q - -
# - - - - Q   Q - - - -
# - Q - - -   - - - Q -
# 
# グループ２: ユニーク解２つ目
# - - - - Q   Q - - - -   - - Q - -   - - Q - -   - - - Q -   - Q - - -   Q - - - -   - - - - Q
# - - Q - -   - - Q - -   Q - - - -   - - - - Q   - Q - - -   - - - Q -   - - - Q -   - Q - - -
# Q - - - -   - - - - Q   - - - Q -   - Q - - -   - - - - Q   Q - - - -   - Q - - -   - - - Q -
# - - - Q -   - Q - - -   - Q - - -   - - - Q -   - - Q - -   - - Q - -   - - - - Q   Q - - - -
# - Q - - -   - - - Q -   - - - - Q   Q - - - -   Q - - - -   - - - - Q   - - Q - -   - - Q - -
#
# 
#   それでは、ユニーク解を判定するための定義付けを行いますが、次のように定義する
# ことにします。各行のクイーンが右から何番目にあるかを調べて、最上段の行から下
# の行へ順番に列挙します。そしてそれをＮ桁の数値として見た場合に最小値になるもの
# をユニーク解として数えることにします。尚、このＮ桁の数を以後は「ユニーク判定値」
# と呼ぶことにします。
# 
# - - - - Q   0
# - - Q - -   2
# Q - - - -   4   --->  0 2 4 1 3  (ユニーク判定値)
# - - - Q -   1
# - Q - - -   3
# 
# 
#   探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定
# するには「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるか
# を調べる」ことになります。しかし結論から先にいえば、ユニーク解とは成り得ないこ
# とが明確なパターンを探索中に切り捨てるある枝刈りを組み込むことにより、３通りの
# 変換を試みるだけでユニーク解の判定が可能になります。
#  
# 
# ■ユニーク解の個数を求める
#   先ず最上段の行のクイーンの位置に着目します。その位置が左半分の領域にあればユ
# ニーク解には成り得ません。何故なら左右反転によって得られるパターンのユニーク判
# 定値の方が確実に小さくなるからです。また、Ｎが奇数の場合に中央にあった場合はど
# うでしょう。これもユニーク解には成り得ません。何故なら仮に中央にあった場合、そ
# れがユニーク解であるためには少なくとも他の外側の３辺におけるクイーンの位置も中
# 央になければならず、それは互いの効き筋にあたるので有り得ません。
#
# ■ユニーク解から全解への展開
#   これまでの考察はユニーク解の個数を求めるためのものでした。全解数を求めるには
# ユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。したがって
# 探索時間を犠牲にしてしまうことになります。そこで「ユニーク解の個数から全解数を
# 導いてしまおう」という試みが考えられます。これは、左右反転によるパターンの探索
# を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。そしてそ
# れを実現させるには「あるユニーク解が属するグループの要素数はいくつあるのか」と
# いう考察が必要になってきます。
# 
#   最初に、クイーンが右上角にあるユニーク解を考えます。斜軸で反転したパターンが
# オリジナルと同型になることは有り得ないことと(×２)、右上角のクイーンを他の３つの
# 角に写像させることができるので(×４)、このユニーク解が属するグループの要素数は必
# ず８個(＝２×４)になります。
# 
#   次に、クイーンが右上角以外にある場合は少し複雑になりますが、考察を簡潔にする
# ために次の事柄を確認します。
#
# TOTAL = (COUNT8 * 8) + (COUNT4 * 4) + (COUNT2 * 2);
#   (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
#    ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
#    ジナルと同型になる。  
#
#    COUNT2 * 2
# 
#   (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナ
#    ルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有
#    り得る。 
#
#    COUNT4 * 4
# 
#   (3) (1) に該当するユニーク解が属するグループの要素数は、左右反転させたパターンを
#       加えて２個しかありません。(2)に該当するユニーク解が属するグループの要素数は、
#       180度回転させて同型になる場合は４個(左右反転×縦横回転)、そして180度回転させても
#       オリジナルと異なる場合は８個になります。(左右反転×縦横回転×上下反転)
# 
#    COUNT8 * 8 
#
#   以上のことから、ひとつひとつのユニーク解が上のどの種類に該当するのかを調べる
# ことにより全解数を計算で導き出すことができます。探索時間を短縮させてくれる枝刈
# りを外す必要がなくなったというわけです。 
# 
#   UNIQUE  COUNT2      +  COUNT4      +  COUNT8
#   TOTAL  (COUNT2 * 2) + (COUNT4 * 4) + (COUNT8 * 8)
#
# 　これらを実現すると、前回のNQueen3()よりも実行速度が遅くなります。
# 　なぜなら、対称・反転・斜軸を反転するための処理が加わっているからです。
# ですが、今回の処理を行うことによって、さらに、処理スピードが飛躍的に高速化されます。そのためにも今回のアルゴリズム実装は必要なのです。
#
#
# 実行結果
#
# <>７．BT＋Bit＋対称解除法 N-Queen7()
#  N:        Total       Unique        hh:mm:ss
#  2:            0            0         0:00:00
#  3:            0            0         0:00:00
#  4:            2            1         0:00:00
#  5:           10            2         0:00:00
#  6:            4            1         0:00:00
#  7:           40            6         0:00:00
#  8:           92           12         0:00:02
#  9:          352           46         0:00:05
# 10:          724           92         0:00:14
# 11:         2680          341         0:01:01
# 12:        14200         1787         0:05:47
#
#
typeset -i TOTAL=0;
typeset -i UNIQUE=0;
typeset -i size=0;
typeset -i MASK=0;
typeset -a board="";
typeset -a trial="";
typeset -a scratch="";
typeset -i COUNT2=0;
typeset -i COUNT4=0;
typeset -i COUNT8=0;
#
function getUnique(){ 
  echo $((COUNT2+COUNT4+COUNT8));
}
#
function getTotal(){ 
  echo $(( COUNT2*2 + COUNT4*4 + COUNT8*8));
}
#
function rotate_bitmap_ts(){
  local -i t=0;
  for((i=0;i<size;i++)){
    t=0;
    for((j=0;j<size;j++)){
      ((t|=((trial[j]>>i)&1)<<(size-j-1))); 
    }
    scratch[$i]=$t; 
  }
}
#
function rotate_bitmap_st(){
  local -i t=0;
  for((i=0;i<size;i++)){
    t=0;
    for((j=0;j<size;j++)){
      ((t|=((scratch[j]>>i)&1)<<(size-j-1))); 
    }
    trial[$i]=$t; 
  }
}
#
function rh(){
  local -i a=$1;
  local -i sz=$2;
  local -i tmp=0;
  for((i=0;i<=sz;i++)){
    ((a&(1<<i)))&&{ 
     (( tmp|=(1<<(sz-i)) )); 
    }
  }
  echo $tmp;
}
#
function vMirror_bitmap(){
  local -i score=0;
  local -i sizeE=$((size-1));
  for((i=0;i<size;i++)){
    score=${scratch[$i]};
    trial[$i]=$(rh "$score" $sizeE);
  }
}
#
function intncmp_bs(){
  local -i rtn=0;
  for((i=0;i<size;i++)){
    rtn=$(echo "${board[$i]}-${scratch[$i]}"+10);
    ((rtn!=10))&&{ break; }
  }
  echo "$rtn";
}
#
function intncmp_bt(){
  local -i rtn=0;
  for((i=0;i<size;i++)){
    rtn=$(echo "${board[$i]}-${trial[$i]}"+10);
    ((rtn!=10))&&{ break; }
  }
  echo "$rtn";
}
#
function symmetryOps_bm(){
  local -i nEquiv=0;
  #回転・反転・対称チェックのためにboard配列をコピー
  for((i=0;i<size;i++)){ 
    trial[$i]=${board[$i]};
  }
  rotate_bitmap_ts; 
  #    //時計回りに90度回転
  k=$(intncmp_bs);
  ((k>10))&&{ 
   return; 
  }
  ((k==10))&&{ 
    nEquiv=2;
  }||{
    rotate_bitmap_st;
    #  //時計回りに180度回転
    k=$(intncmp_bt);
    ((k>10))&&{ 
     return; 
    }
    ((k==10))&&{ 
      nEquiv=4;
    }||{
      rotate_bitmap_ts;
      #//時計回りに270度回転
      k=$(intncmp_bs);
      ((k>10))&&{ 
        return;
      }
      nEquiv=8;
    }
  }
  #// 回転・反転・対称チェックのためにboard配列をコピー
  for((i=0;i<size;i++)){ 
    scratch[$i]=${board[$i]};
  }
  vMirror_bitmap;
  #//垂直反転
  k=$(intncmp_bt);
  ((k>10))&&{ 
   return; 
  }
  ((nEquiv>2))&&{
  #               //-90度回転 対角鏡と同等       
    rotate_bitmap_ts;
    k=$(intncmp_bs);
    ((k>10))&&{
      return;
    }
    ((nEquiv>4))&&{
    #             //-180度回転 水平鏡像と同等
      rotate_bitmap_st;
      k=$(intncmp_bt);
      ((k>10))&&{ 
        return;
      } 
      #      //-270度回転 反対角鏡と同等
      rotate_bitmap_ts;
      k=$(intncmp_bs);
      ((k>10))&&{ 
        return;
      }
    }
  }
  ((nEquiv==2))&&{
    ((COUNT2++));
  }
  ((nEquiv==4))&&{
    ((COUNT4++));
  }
  ((nEquiv==8))&&{
    ((COUNT8++));
  }
}
#
function N-Queen7_rec(){
	#y: l:left d:down r:right b:bit bm:bitmap
  local -i min="$1";
	local -i left="$2";
	local -i down="$3";
	local -i right="$4";
	local -i bitmap=0;
  bitmap=$((MASK&~(left|down|right)));
  ((min==size&&!bitmap))&&{
    board[$min]=$bitmap;
    symmetryOps_bm;
	}||{
    while ((bitmap)); do
      bit=$((-bitmap&bitmap)) ;
      board[$min]=$bit;
      bitmap=$((bitmap^bit)) ;
      N-Queen7_rec "$((min+1))" "$(((left|bit)<<1))" "$((down|bit))" "$(((right|bit)>>1))"  ;
    done
  }
}
#
function N-Queen7(){
  local -i max=15;
	local -i min=2;
	local startTime=;
	local endTime= ;
	local hh=mm=ss=0; 		# いっぺんにに初期化することもできます
  echo " N:        Total       Unique        hh:mm:ss" ;
  for ((size=min;size<=max;size++)) {
    TOTAL=0;
		UNIQUE=0;
    COUNT2=COUNT4=COUNT8=0;
    for((j=0;j<size;j++)){
     board[$j]=$j; 
    }
		MASK=$(((1<<size)-1));
    startTime=$(date +%s);# 計測開始時間
    N-Queen7_rec 0 0 0 0 ;
    endTime=$(date +%s); 	# 計測終了時間
    ss=$((endTime-startTime));# hh:mm:ss 形式に変換
    hh=$((ss/3600));
    ss=$((ss%3600));
    mm=$((ss/60));
    ss=$((ss%60));
    TOTAL=$(getTotal);
    UNIQUE=$(getUnique);
    printf "%2d:%13d%13d%10d:%.2d:%.2d\n" $size $TOTAL $UNIQUE $hh $mm $ss ;
  } 
}
#
  echo "<>７．BT＋Bit＋対称解除法 N-Queen7()";
  N-Queen7;
#
